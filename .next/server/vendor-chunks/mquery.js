"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mquery";
exports.ids = ["vendor-chunks/mquery"];
exports.modules = {

/***/ "(ssr)/./node_modules/mquery/lib/collection/collection.js":
/*!**********************************************************!*\
  !*** ./node_modules/mquery/lib/collection/collection.js ***!
  \**********************************************************/
/***/ ((module, exports) => {

eval("\n/**\n * methods a collection must implement\n */ const methods = [\n    \"find\",\n    \"findOne\",\n    \"updateMany\",\n    \"updateOne\",\n    \"replaceOne\",\n    \"count\",\n    \"distinct\",\n    \"findOneAndDelete\",\n    \"findOneAndUpdate\",\n    \"aggregate\",\n    \"findCursor\",\n    \"deleteOne\",\n    \"deleteMany\"\n];\n/**\n * Collection base class from which implementations inherit\n */ function Collection() {}\nfor(let i = 0, len = methods.length; i < len; ++i){\n    const method = methods[i];\n    Collection.prototype[method] = notImplemented(method);\n}\nmodule.exports = exports = Collection;\nCollection.methods = methods;\n/**\n * creates a function which throws an implementation error\n */ function notImplemented(method) {\n    return function() {\n        throw new Error(\"collection.\" + method + \" not implemented\");\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Q0FFQyxHQUVELE1BQU1BLFVBQVU7SUFDZDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQ7O0NBRUMsR0FFRCxTQUFTQyxjQUFjO0FBRXZCLElBQUssSUFBSUMsSUFBSSxHQUFHQyxNQUFNSCxRQUFRSSxNQUFNLEVBQUVGLElBQUlDLEtBQUssRUFBRUQsRUFBRztJQUNsRCxNQUFNRyxTQUFTTCxPQUFPLENBQUNFLEVBQUU7SUFDekJELFdBQVdLLFNBQVMsQ0FBQ0QsT0FBTyxHQUFHRSxlQUFlRjtBQUNoRDtBQUVBRyxPQUFPQyxPQUFPLEdBQUdBLFVBQVVSO0FBQzNCQSxXQUFXRCxPQUFPLEdBQUdBO0FBRXJCOztDQUVDLEdBRUQsU0FBU08sZUFBZUYsTUFBTTtJQUM1QixPQUFPO1FBQ0wsTUFBTSxJQUFJSyxNQUFNLGdCQUFnQkwsU0FBUztJQUMzQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWRtaW4vLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24uanM/NjU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogbWV0aG9kcyBhIGNvbGxlY3Rpb24gbXVzdCBpbXBsZW1lbnRcbiAqL1xuXG5jb25zdCBtZXRob2RzID0gW1xuICAnZmluZCcsXG4gICdmaW5kT25lJyxcbiAgJ3VwZGF0ZU1hbnknLFxuICAndXBkYXRlT25lJyxcbiAgJ3JlcGxhY2VPbmUnLFxuICAnY291bnQnLFxuICAnZGlzdGluY3QnLFxuICAnZmluZE9uZUFuZERlbGV0ZScsXG4gICdmaW5kT25lQW5kVXBkYXRlJyxcbiAgJ2FnZ3JlZ2F0ZScsXG4gICdmaW5kQ3Vyc29yJyxcbiAgJ2RlbGV0ZU9uZScsXG4gICdkZWxldGVNYW55J1xuXTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIGJhc2UgY2xhc3MgZnJvbSB3aGljaCBpbXBsZW1lbnRhdGlvbnMgaW5oZXJpdFxuICovXG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24oKSB7fVxuXG5mb3IgKGxldCBpID0gMCwgbGVuID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBjb25zdCBtZXRob2QgPSBtZXRob2RzW2ldO1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbm90SW1wbGVtZW50ZWQobWV0aG9kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ29sbGVjdGlvbjtcbkNvbGxlY3Rpb24ubWV0aG9kcyA9IG1ldGhvZHM7XG5cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIHRocm93cyBhbiBpbXBsZW1lbnRhdGlvbiBlcnJvclxuICovXG5cbmZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb2xsZWN0aW9uLicgKyBtZXRob2QgKyAnIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9O1xufVxuIl0sIm5hbWVzIjpbIm1ldGhvZHMiLCJDb2xsZWN0aW9uIiwiaSIsImxlbiIsImxlbmd0aCIsIm1ldGhvZCIsInByb3RvdHlwZSIsIm5vdEltcGxlbWVudGVkIiwibW9kdWxlIiwiZXhwb3J0cyIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/collection/collection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/collection/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mquery/lib/collection/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst env = __webpack_require__(/*! ../env */ \"(ssr)/./node_modules/mquery/lib/env.js\");\nif (\"unknown\" == env.type) {\n    throw new Error(\"Unknown environment\");\n}\nmodule.exports = env.isNode ? __webpack_require__(/*! ./node */ \"(ssr)/./node_modules/mquery/lib/collection/node.js\") : env.isMongo ? __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\") : __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFFcEIsSUFBSSxhQUFhRCxJQUFJRSxJQUFJLEVBQUU7SUFDekIsTUFBTSxJQUFJQyxNQUFNO0FBQ2xCO0FBRUFDLE9BQU9DLE9BQU8sR0FDWkwsSUFBSU0sTUFBTSxHQUFHTCxtQkFBT0EsQ0FBQyxzRUFDbkJELElBQUlPLE9BQU8sR0FBR04sbUJBQU9BLENBQUMsa0ZBQ3BCQSxtQkFBT0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FkbWluLy4vbm9kZV9tb2R1bGVzL21xdWVyeS9saWIvY29sbGVjdGlvbi9pbmRleC5qcz83YmU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZW52ID0gcmVxdWlyZSgnLi4vZW52Jyk7XG5cbmlmICgndW5rbm93bicgPT0gZW52LnR5cGUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVudmlyb25tZW50Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID1cbiAgZW52LmlzTm9kZSA/IHJlcXVpcmUoJy4vbm9kZScpIDpcbiAgICBlbnYuaXNNb25nbyA/IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpIDpcbiAgICAgIHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuXG4iXSwibmFtZXMiOlsiZW52IiwicmVxdWlyZSIsInR5cGUiLCJFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc05vZGUiLCJpc01vbmdvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/collection/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/collection/node.js":
/*!****************************************************!*\
  !*** ./node_modules/mquery/lib/collection/node.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n/**\n * Module dependencies\n */ const Collection = __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\");\nclass NodeCollection extends Collection {\n    constructor(col){\n        super();\n        this.collection = col;\n        this.collectionName = col.collectionName;\n    }\n    /**\n   * find(match, options)\n   */ async find(match, options) {\n        const cursor = this.collection.find(match, options);\n        return cursor.toArray();\n    }\n    /**\n   * findOne(match, options)\n   */ async findOne(match, options) {\n        return this.collection.findOne(match, options);\n    }\n    /**\n   * count(match, options)\n   */ async count(match, options) {\n        return this.collection.count(match, options);\n    }\n    /**\n   * distinct(prop, match, options)\n   */ async distinct(prop, match, options) {\n        return this.collection.distinct(prop, match, options);\n    }\n    /**\n   * updateMany(match, update, options)\n   */ async updateMany(match, update, options) {\n        return this.collection.updateMany(match, update, options);\n    }\n    /**\n   * updateOne(match, update, options)\n   */ async updateOne(match, update, options) {\n        return this.collection.updateOne(match, update, options);\n    }\n    /**\n   * replaceOne(match, update, options)\n   */ async replaceOne(match, update, options) {\n        return this.collection.replaceOne(match, update, options);\n    }\n    /**\n   * deleteOne(match, options)\n   */ async deleteOne(match, options) {\n        return this.collection.deleteOne(match, options);\n    }\n    /**\n   * deleteMany(match, options)\n   */ async deleteMany(match, options) {\n        return this.collection.deleteMany(match, options);\n    }\n    /**\n   * findOneAndDelete(match, options, function(err[, result])\n   */ async findOneAndDelete(match, options) {\n        return this.collection.findOneAndDelete(match, options);\n    }\n    /**\n   * findOneAndUpdate(match, update, options)\n   */ async findOneAndUpdate(match, update, options) {\n        return this.collection.findOneAndUpdate(match, update, options);\n    }\n    /**\n   * var cursor = findCursor(match, options)\n   */ findCursor(match, options) {\n        return this.collection.find(match, options);\n    }\n}\n/**\n * Expose\n */ module.exports = exports = NodeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Q0FFQyxHQUVELE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDO0FBRTNCLE1BQU1DLHVCQUF1QkY7SUFDM0JHLFlBQVlDLEdBQUcsQ0FBRTtRQUNmLEtBQUs7UUFFTCxJQUFJLENBQUNDLFVBQVUsR0FBR0Q7UUFDbEIsSUFBSSxDQUFDRSxjQUFjLEdBQUdGLElBQUlFLGNBQWM7SUFDMUM7SUFFQTs7R0FFQyxHQUNELE1BQU1DLEtBQUtDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ3pCLE1BQU1DLFNBQVMsSUFBSSxDQUFDTCxVQUFVLENBQUNFLElBQUksQ0FBQ0MsT0FBT0M7UUFFM0MsT0FBT0MsT0FBT0MsT0FBTztJQUN2QjtJQUVBOztHQUVDLEdBQ0QsTUFBTUMsUUFBUUosS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDNUIsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ08sT0FBTyxDQUFDSixPQUFPQztJQUN4QztJQUVBOztHQUVDLEdBQ0QsTUFBTUksTUFBTUwsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ1EsS0FBSyxDQUFDTCxPQUFPQztJQUN0QztJQUVBOztHQUVDLEdBQ0QsTUFBTUssU0FBU0MsSUFBSSxFQUFFUCxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNuQyxPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDUyxRQUFRLENBQUNDLE1BQU1QLE9BQU9DO0lBQy9DO0lBRUE7O0dBRUMsR0FDRCxNQUFNTyxXQUFXUixLQUFLLEVBQUVTLE1BQU0sRUFBRVIsT0FBTyxFQUFFO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDSixVQUFVLENBQUNXLFVBQVUsQ0FBQ1IsT0FBT1MsUUFBUVI7SUFDbkQ7SUFFQTs7R0FFQyxHQUNELE1BQU1TLFVBQVVWLEtBQUssRUFBRVMsTUFBTSxFQUFFUixPQUFPLEVBQUU7UUFDdEMsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ2EsU0FBUyxDQUFDVixPQUFPUyxRQUFRUjtJQUNsRDtJQUVBOztHQUVDLEdBQ0QsTUFBTVUsV0FBV1gsS0FBSyxFQUFFUyxNQUFNLEVBQUVSLE9BQU8sRUFBRTtRQUN2QyxPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDYyxVQUFVLENBQUNYLE9BQU9TLFFBQVFSO0lBQ25EO0lBRUE7O0dBRUMsR0FDRCxNQUFNVyxVQUFVWixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUM5QixPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDZSxTQUFTLENBQUNaLE9BQU9DO0lBQzFDO0lBRUE7O0dBRUMsR0FDRCxNQUFNWSxXQUFXYixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUMvQixPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDZ0IsVUFBVSxDQUFDYixPQUFPQztJQUMzQztJQUVBOztHQUVDLEdBQ0QsTUFBTWEsaUJBQWlCZCxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDaUIsZ0JBQWdCLENBQUNkLE9BQU9DO0lBQ2pEO0lBRUE7O0dBRUMsR0FDRCxNQUFNYyxpQkFBaUJmLEtBQUssRUFBRVMsTUFBTSxFQUFFUixPQUFPLEVBQUU7UUFDN0MsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ2tCLGdCQUFnQixDQUFDZixPQUFPUyxRQUFRUjtJQUN6RDtJQUVBOztHQUVDLEdBQ0RlLFdBQVdoQixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUN6QixPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDRSxJQUFJLENBQUNDLE9BQU9DO0lBQ3JDO0FBTUY7QUFHQTs7Q0FFQyxHQUVEZ0IsT0FBT0MsT0FBTyxHQUFHQSxVQUFVeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZG1pbi8uL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL2NvbGxlY3Rpb24vbm9kZS5qcz80MzM2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuXG5jbGFzcyBOb2RlQ29sbGVjdGlvbiBleHRlbmRzIENvbGxlY3Rpb24ge1xuICBjb25zdHJ1Y3Rvcihjb2wpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jb2xsZWN0aW9uID0gY29sO1xuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUgPSBjb2wuY29sbGVjdGlvbk5hbWU7XG4gIH1cblxuICAvKipcbiAgICogZmluZChtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGZpbmQobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmNvbGxlY3Rpb24uZmluZChtYXRjaCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gY3Vyc29yLnRvQXJyYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kT25lKG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZmluZE9uZShtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmluZE9uZShtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogY291bnQobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBjb3VudChtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uY291bnQobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRpc3RpbmN0KHByb3AsIG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZGlzdGluY3QocHJvcCwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmRpc3RpbmN0KHByb3AsIG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB1cGRhdGVNYW55KG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyB1cGRhdGVNYW55KG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLnVwZGF0ZU1hbnkobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyB1cGRhdGVPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24udXBkYXRlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlcGxhY2VPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIHJlcGxhY2VPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24ucmVwbGFjZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWxldGVPbmUobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBkZWxldGVPbmUobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmRlbGV0ZU9uZShtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZGVsZXRlTWFueShtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGRlbGV0ZU1hbnkobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmRlbGV0ZU1hbnkobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmRPbmVBbmREZWxldGUobWF0Y2gsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyclssIHJlc3VsdF0pXG4gICAqL1xuICBhc3luYyBmaW5kT25lQW5kRGVsZXRlKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5maW5kT25lQW5kRGVsZXRlKG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kT25lQW5kVXBkYXRlKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBmaW5kT25lQW5kVXBkYXRlKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmZpbmRPbmVBbmRVcGRhdGUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogdmFyIGN1cnNvciA9IGZpbmRDdXJzb3IobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBmaW5kQ3Vyc29yKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5maW5kKG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhZ2dyZWdhdGlvbihvcGVyYXRvcnMuLi4pXG4gICAqIFRPRE9cbiAgICovXG59XG5cblxuLyoqXG4gKiBFeHBvc2VcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBOb2RlQ29sbGVjdGlvbjtcbiJdLCJuYW1lcyI6WyJDb2xsZWN0aW9uIiwicmVxdWlyZSIsIk5vZGVDb2xsZWN0aW9uIiwiY29uc3RydWN0b3IiLCJjb2wiLCJjb2xsZWN0aW9uIiwiY29sbGVjdGlvbk5hbWUiLCJmaW5kIiwibWF0Y2giLCJvcHRpb25zIiwiY3Vyc29yIiwidG9BcnJheSIsImZpbmRPbmUiLCJjb3VudCIsImRpc3RpbmN0IiwicHJvcCIsInVwZGF0ZU1hbnkiLCJ1cGRhdGUiLCJ1cGRhdGVPbmUiLCJyZXBsYWNlT25lIiwiZGVsZXRlT25lIiwiZGVsZXRlTWFueSIsImZpbmRPbmVBbmREZWxldGUiLCJmaW5kT25lQW5kVXBkYXRlIiwiZmluZEN1cnNvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/collection/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/env.js":
/*!****************************************!*\
  !*** ./node_modules/mquery/lib/env.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.isNode = \"undefined\" != typeof process && \"object\" == \"object\" && \"object\" == typeof global && \"function\" == typeof Buffer && process.argv;\nexports.isMongo = !exports.isNode && \"function\" == typeof printjson && \"function\" == typeof ObjectId && \"function\" == typeof rs && \"function\" == typeof sh;\nexports.isBrowser = !exports.isNode && !exports.isMongo && \"undefined\" != \"undefined\";\nexports.type = exports.isNode ? \"node\" : exports.isMongo ? \"mongo\" : exports.isBrowser ? \"browser\" : \"unknown\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9lbnYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsY0FBYyxHQUFHLGVBQWUsT0FBT0UsV0FDekIsWUFBWSxRQUFhQyxJQUN6QixZQUFZLE9BQU9DLFVBQ25CLGNBQWMsT0FBT0MsVUFDckJILFFBQVFJLElBQUk7QUFFMUJOLGVBQWUsR0FBRyxDQUFDQSxRQUFRQyxNQUFNLElBQ25CLGNBQWMsT0FBT08sYUFDckIsY0FBYyxPQUFPQyxZQUNyQixjQUFjLE9BQU9DLE1BQ3JCLGNBQWMsT0FBT0M7QUFFbkNYLGlCQUFpQixHQUFHLENBQUNBLFFBQVFDLE1BQU0sSUFDZixDQUFDRCxRQUFRTyxPQUFPLElBQ2hCLGVBQWU7QUFFbkNQLFlBQVksR0FBR0EsUUFBUUMsTUFBTSxHQUFHLFNBQzVCRCxRQUFRTyxPQUFPLEdBQUcsVUFDaEJQLFFBQVFZLFNBQVMsR0FBRyxZQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FkbWluLy4vbm9kZV9tb2R1bGVzL21xdWVyeS9saWIvZW52LmpzPzFlZTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmlzTm9kZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBwcm9jZXNzXG4gICAgICAgICAgICYmICdvYmplY3QnID09IHR5cGVvZiBtb2R1bGVcbiAgICAgICAgICAgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGdsb2JhbFxuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBCdWZmZXJcbiAgICAgICAgICAgJiYgcHJvY2Vzcy5hcmd2O1xuXG5leHBvcnRzLmlzTW9uZ28gPSAhZXhwb3J0cy5pc05vZGVcbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgcHJpbnRqc29uXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIE9iamVjdElkXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIHJzXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIHNoO1xuXG5leHBvcnRzLmlzQnJvd3NlciA9ICFleHBvcnRzLmlzTm9kZVxuICAgICAgICAgICAgICAgICAmJiAhZXhwb3J0cy5pc01vbmdvXG4gICAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiB3aW5kb3c7XG5cbmV4cG9ydHMudHlwZSA9IGV4cG9ydHMuaXNOb2RlID8gJ25vZGUnXG4gIDogZXhwb3J0cy5pc01vbmdvID8gJ21vbmdvJ1xuICAgIDogZXhwb3J0cy5pc0Jyb3dzZXIgPyAnYnJvd3NlcidcbiAgICAgIDogJ3Vua25vd24nO1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJpc05vZGUiLCJwcm9jZXNzIiwibW9kdWxlIiwiZ2xvYmFsIiwiQnVmZmVyIiwiYXJndiIsImlzTW9uZ28iLCJwcmludGpzb24iLCJPYmplY3RJZCIsInJzIiwic2giLCJpc0Jyb3dzZXIiLCJ0eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/mquery.js":
/*!*******************************************!*\
  !*** ./node_modules/mquery/lib/mquery.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n/**\n * Dependencies\n */ const assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mquery/lib/utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")(\"mquery\");\n/**\n * Query constructor used for building queries.\n *\n * #### Example:\n *\n *     var query = new Query({ name: 'mquery' });\n *     query.setOptions({ collection: moduleCollection })\n *     await query.where('age').gte(21).exec();\n *\n * @param {Object} [criteria] criteria for the query OR the collection instance to use\n * @param {Object} [options]\n * @api public\n */ function Query(criteria, options) {\n    if (!(this instanceof Query)) return new Query(criteria, options);\n    const proto = this.constructor.prototype;\n    this.op = proto.op || undefined;\n    this.options = Object.assign({}, proto.options);\n    this._conditions = proto._conditions ? utils.clone(proto._conditions) : {};\n    this._fields = proto._fields ? utils.clone(proto._fields) : undefined;\n    this._updateDoc = proto._updateDoc ? utils.clone(proto._updateDoc) : undefined;\n    this._path = proto._path || undefined;\n    this._distinctDoc = proto._distinctDoc || undefined;\n    this._collection = proto._collection || undefined;\n    this._traceFunction = proto._traceFunction || undefined;\n    if (options) {\n        this.setOptions(options);\n    }\n    if (criteria) {\n        this.find(criteria);\n    }\n}\n/**\n * This is a parameter that the user can set which determines if mquery\n * uses $within or $geoWithin for queries. It defaults to true which\n * means $geoWithin will be used. If using MongoDB < 2.4 you should\n * set this to false.\n *\n * @api public\n * @property use$geoWithin\n */ let $withinCmd = \"$geoWithin\";\nObject.defineProperty(Query, \"use$geoWithin\", {\n    get: function() {\n        return $withinCmd == \"$geoWithin\";\n    },\n    set: function(v) {\n        if (true === v) {\n            // mongodb >= 2.4\n            $withinCmd = \"$geoWithin\";\n        } else {\n            $withinCmd = \"$within\";\n        }\n    }\n});\n/**\n * Converts this query to a constructor function with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query that will read documents with a \"video\" category from\n *     // `aCollection` on the primary node in the replica-set unless it is down,\n *     // in which case we'll read from a secondary node.\n *     var query = mquery({ category: 'video' })\n *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });\n *\n *     // create a constructor based off these settings\n *     var Video = query.toConstructor();\n *\n *     // Video is now a subclass of mquery() and works the same way but with the\n *     // default query parameters and options set.\n *\n *     // run a query with the previous settings but filter for movies with names\n *     // that start with \"Life\".\n *     Video().where({ name: /^Life/ }).exec(cb);\n *\n * @return {Query} new Query\n * @api public\n */ Query.prototype.toConstructor = function toConstructor() {\n    function CustomQuery(criteria, options) {\n        if (!(this instanceof CustomQuery)) return new CustomQuery(criteria, options);\n        Query.call(this, criteria, options);\n    }\n    utils.inherits(CustomQuery, Query);\n    // set inherited defaults\n    const p = CustomQuery.prototype;\n    p.options = {};\n    p.setOptions(this.options);\n    p.op = this.op;\n    p._conditions = utils.clone(this._conditions);\n    p._fields = utils.clone(this._fields);\n    p._updateDoc = utils.clone(this._updateDoc);\n    p._path = this._path;\n    p._distinctDoc = this._distinctDoc;\n    p._collection = this._collection;\n    p._traceFunction = this._traceFunction;\n    return CustomQuery;\n};\n/**\n * Sets query options.\n *\n * #### Options:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D) *\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *\n * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *\n * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *\n * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)\n * - collection the collection to query against\n *\n * _* denotes a query helper method is also available_\n *\n * @param {Object} options\n * @api public\n */ Query.prototype.setOptions = function(options) {\n    if (!(options && utils.isObject(options))) return this;\n    // set arbitrary options\n    const methods = utils.keys(options);\n    let method;\n    for(let i = 0; i < methods.length; ++i){\n        method = methods[i];\n        // use methods if exist (safer option manipulation)\n        if (\"function\" == typeof this[method]) {\n            const args = Array.isArray(options[method]) ? options[method] : [\n                options[method]\n            ];\n            this[method].apply(this, args);\n        } else {\n            this.options[method] = options[method];\n        }\n    }\n    return this;\n};\n/**\n * Sets this Querys collection.\n *\n * @param {Collection} coll\n * @return {Query} this\n */ Query.prototype.collection = function collection(coll) {\n    this._collection = new Query.Collection(coll);\n    return this;\n};\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * #### Example:\n *\n *     query.find().collation({ locale: \"en_US\", strength: 1 })\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */ Query.prototype.collation = function(value) {\n    this.options.collation = value;\n    return this;\n};\n/**\n * Specifies a `$where` condition\n *\n * Use `$where` when you need to select documents using a JavaScript expression.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length > 10 || this.name.length > 5')\n *\n *     query.$where(function () {\n *       return this.comments.length > 10 || this.name.length > 5;\n *     })\n *\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @method $where\n * @api public\n */ Query.prototype.$where = function(js) {\n    this._conditions.$where = js;\n    return this;\n};\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     await User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     await User\n *       .where('age').gte(21).lte(65)\n *       .where('name', /^vonderful/i)\n *       .where('friends').slice(10)\n *       .exec()\n *\n * @param {String} [path]\n * @param {Object} [val]\n * @return {Query} this\n * @api public\n */ Query.prototype.where = function() {\n    if (!arguments.length) return this;\n    if (!this.op) this.op = \"find\";\n    const type = typeof arguments[0];\n    if (\"string\" == type) {\n        this._path = arguments[0];\n        if (2 === arguments.length) {\n            this._conditions[this._path] = arguments[1];\n        }\n        return this;\n    }\n    if (\"object\" == type && !Array.isArray(arguments[0])) {\n        return this.merge(arguments[0]);\n    }\n    throw new TypeError(\"path must be a string or object\");\n};\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */ Query.prototype.equals = function equals(val) {\n    this._ensurePath(\"equals\");\n    const path = this._path;\n    this._conditions[path] = val;\n    return this;\n};\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n * This is alias of `equals`\n *\n * #### Example:\n *\n *     User.where('age').eq(49);\n *\n *     // is the same as\n *\n *     User.shere('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */ Query.prototype.eq = function eq(val) {\n    this._ensurePath(\"eq\");\n    const path = this._path;\n    this._conditions[path] = val;\n    return this;\n};\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */ Query.prototype.or = function or(array) {\n    const or = this._conditions.$or || (this._conditions.$or = []);\n    if (!Array.isArray(array)) array = [\n        array\n    ];\n    or.push.apply(or, array);\n    return this;\n};\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */ Query.prototype.nor = function nor(array) {\n    const nor = this._conditions.$nor || (this._conditions.$nor = []);\n    if (!Array.isArray(array)) array = [\n        array\n    ];\n    nor.push.apply(nor, array);\n    return this;\n};\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @see $and http://docs.mongodb.org/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */ Query.prototype.and = function and(array) {\n    const and = this._conditions.$and || (this._conditions.$and = []);\n    if (!Array.isArray(array)) array = [\n        array\n    ];\n    and.push.apply(and, array);\n    return this;\n};\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method ne\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method in\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method nin\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method all\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method size\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method regex\n * @memberOf Query\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */ /**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method maxDistance\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /*!\n * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance\n *\n *     Thing.where('type').nin(array)\n */ \"gt gte lt lte ne in nin all regex size maxDistance minDistance\".split(\" \").forEach(function($conditional) {\n    Query.prototype[$conditional] = function() {\n        let path, val;\n        if (1 === arguments.length) {\n            this._ensurePath($conditional);\n            val = arguments[0];\n            path = this._path;\n        } else {\n            val = arguments[1];\n            path = arguments[0];\n        }\n        const conds = this._conditions[path] === null || typeof this._conditions[path] === \"object\" ? this._conditions[path] : this._conditions[path] = {};\n        conds[\"$\" + $conditional] = val;\n        return this;\n    };\n});\n/**\n * Specifies a `$mod` condition\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */ Query.prototype.mod = function() {\n    let val, path;\n    if (1 === arguments.length) {\n        this._ensurePath(\"mod\");\n        val = arguments[0];\n        path = this._path;\n    } else if (2 === arguments.length && !Array.isArray(arguments[1])) {\n        this._ensurePath(\"mod\");\n        val = [\n            arguments[0],\n            arguments[1]\n        ];\n        path = this._path;\n    } else if (3 === arguments.length) {\n        val = [\n            arguments[1],\n            arguments[2]\n        ];\n        path = arguments[0];\n    } else {\n        val = arguments[1];\n        path = arguments[0];\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds.$mod = val;\n    return this;\n};\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */ Query.prototype.exists = function() {\n    let path, val;\n    if (0 === arguments.length) {\n        this._ensurePath(\"exists\");\n        path = this._path;\n        val = true;\n    } else if (1 === arguments.length) {\n        if (\"boolean\" === typeof arguments[0]) {\n            this._ensurePath(\"exists\");\n            path = this._path;\n            val = arguments[0];\n        } else {\n            path = arguments[0];\n            val = true;\n        }\n    } else if (2 === arguments.length) {\n        path = arguments[0];\n        val = arguments[1];\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds.$exists = val;\n    return this;\n};\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @api public\n */ Query.prototype.elemMatch = function() {\n    if (null == arguments[0]) throw new TypeError(\"Invalid argument\");\n    let fn, path, criteria;\n    if (\"function\" === typeof arguments[0]) {\n        this._ensurePath(\"elemMatch\");\n        path = this._path;\n        fn = arguments[0];\n    } else if (utils.isObject(arguments[0])) {\n        this._ensurePath(\"elemMatch\");\n        path = this._path;\n        criteria = arguments[0];\n    } else if (\"function\" === typeof arguments[1]) {\n        path = arguments[0];\n        fn = arguments[1];\n    } else if (arguments[1] && utils.isObject(arguments[1])) {\n        path = arguments[0];\n        criteria = arguments[1];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (fn) {\n        criteria = new Query;\n        fn(criteria);\n        criteria = criteria._conditions;\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds.$elemMatch = criteria;\n    return this;\n};\n// Spatial queries\n/**\n * Sugar for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.within().box()\n *     query.within().circle()\n *     query.within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * #### Note:\n *\n * Must be used after `where()`.\n *\n * @memberOf Query\n * @return {Query} this\n * @api public\n */ Query.prototype.within = function within() {\n    // opinionated, must be used after where\n    this._ensurePath(\"within\");\n    this._geoComparison = $withinCmd;\n    if (0 === arguments.length) {\n        return this;\n    }\n    if (2 === arguments.length) {\n        return this.box.apply(this, arguments);\n    } else if (2 < arguments.length) {\n        return this.polygon.apply(this, arguments);\n    }\n    const area = arguments[0];\n    if (!area) throw new TypeError(\"Invalid argument\");\n    if (area.center) return this.circle(area);\n    if (area.box) return this.box.apply(this, area.box);\n    if (area.polygon) return this.polygon.apply(this, area.polygon);\n    if (area.type && area.coordinates) return this.geometry(area);\n    throw new TypeError(\"Invalid argument\");\n};\n/**\n * Specifies a $box condition\n *\n * #### Example:\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box('loc', lowerLeft, upperRight )\n *\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see Query#within #query_Query-within\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @api public\n */ Query.prototype.box = function() {\n    let path, box;\n    if (3 === arguments.length) {\n        // box('loc', [], [])\n        path = arguments[0];\n        box = [\n            arguments[1],\n            arguments[2]\n        ];\n    } else if (2 === arguments.length) {\n        // box([], [])\n        this._ensurePath(\"box\");\n        path = this._path;\n        box = [\n            arguments[0],\n            arguments[1]\n        ];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds[this._geoComparison || $withinCmd] = {\n        $box: box\n    };\n    return this;\n};\n/**\n * Specifies a $polygon condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])\n *     query.polygon('loc', [10,20], [13, 25], [7,15])\n *\n * @param {String|Array} [path]\n * @param {Array|Object} [val]\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */ Query.prototype.polygon = function() {\n    let val, path;\n    if (\"string\" == typeof arguments[0]) {\n        // polygon('loc', [],[],[])\n        val = Array.from(arguments);\n        path = val.shift();\n    } else {\n        // polygon([],[],[])\n        this._ensurePath(\"polygon\");\n        path = this._path;\n        val = Array.from(arguments);\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds[this._geoComparison || $withinCmd] = {\n        $polygon: val\n    };\n    return this;\n};\n/**\n * Specifies a $center or $centerSphere condition.\n *\n * #### Example:\n *\n *     var area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n *     // for spherical calculations\n *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */ Query.prototype.circle = function() {\n    let path, val;\n    if (1 === arguments.length) {\n        this._ensurePath(\"circle\");\n        path = this._path;\n        val = arguments[0];\n    } else if (2 === arguments.length) {\n        path = arguments[0];\n        val = arguments[1];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (!(\"radius\" in val && val.center)) throw new Error(\"center and radius are required\");\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    const type = val.spherical ? \"$centerSphere\" : \"$center\";\n    const wKey = this._geoComparison || $withinCmd;\n    conds[wKey] = {};\n    conds[wKey][type] = [\n        val.center,\n        val.radius\n    ];\n    if (\"unique\" in val) conds[wKey].$uniqueDocs = !!val.unique;\n    return this;\n};\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *     query.near({ center: { type: 'Point', coordinates: [..] }})\n *     query.near().geometry({ type: 'Point', coordinates: [..] })\n *\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */ Query.prototype.near = function near() {\n    let path, val;\n    this._geoComparison = \"$near\";\n    if (0 === arguments.length) {\n        return this;\n    } else if (1 === arguments.length) {\n        this._ensurePath(\"near\");\n        path = this._path;\n        val = arguments[0];\n    } else if (2 === arguments.length) {\n        path = arguments[0];\n        val = arguments[1];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (!val.center) {\n        throw new Error(\"center is required\");\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    const type = val.spherical ? \"$nearSphere\" : \"$near\";\n    // center could be a GeoJSON object or an Array\n    if (Array.isArray(val.center)) {\n        conds[type] = val.center;\n        const radius = \"maxDistance\" in val ? val.maxDistance : null;\n        if (null != radius) {\n            conds.$maxDistance = radius;\n        }\n        if (null != val.minDistance) {\n            conds.$minDistance = val.minDistance;\n        }\n    } else {\n        // GeoJSON?\n        if (val.center.type != \"Point\" || !Array.isArray(val.center.coordinates)) {\n            throw new Error(util.format(\"Invalid GeoJSON specified for %s\", type));\n        }\n        conds[type] = {\n            $geometry: val.center\n        };\n        // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere\n        if (\"maxDistance\" in val) {\n            conds[type][\"$maxDistance\"] = val.maxDistance;\n        }\n        if (\"minDistance\" in val) {\n            conds[type][\"$minDistance\"] = val.minDistance;\n        }\n    }\n    return this;\n};\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n *     query.where('path').intersects({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n * @param {Object} [arg]\n * @return {Query} this\n * @api public\n */ Query.prototype.intersects = function intersects() {\n    // opinionated, must be used after where\n    this._ensurePath(\"intersects\");\n    this._geoComparison = \"$geoIntersects\";\n    if (0 === arguments.length) {\n        return this;\n    }\n    const area = arguments[0];\n    if (null != area && area.type && area.coordinates) return this.geometry(area);\n    throw new TypeError(\"Invalid argument\");\n};\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     var polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     var polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * The most recent path passed to `where()` is used.\n *\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @api public\n */ Query.prototype.geometry = function geometry() {\n    if (!(\"$within\" == this._geoComparison || \"$geoWithin\" == this._geoComparison || \"$near\" == this._geoComparison || \"$geoIntersects\" == this._geoComparison)) {\n        throw new Error(\"geometry() must come after `within()`, `intersects()`, or `near()\");\n    }\n    let val, path;\n    if (1 === arguments.length) {\n        this._ensurePath(\"geometry\");\n        path = this._path;\n        val = arguments[0];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (!(val.type && Array.isArray(val.coordinates))) {\n        throw new TypeError(\"Invalid argument\");\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds[this._geoComparison] = {\n        $geometry: val\n    };\n    return this;\n};\n// end spatial\n/**\n * Specifies which document fields to include or exclude\n *\n * #### String syntax\n *\n * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n *\n * #### Example:\n *\n *     // include a and b, exclude c\n *     query.select('a b -c');\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({a: 1, b: 1, c: 0});\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */ Query.prototype.select = function select() {\n    let arg = arguments[0];\n    if (!arg) return this;\n    if (arguments.length !== 1) {\n        throw new Error(\"Invalid select: select only takes 1 argument\");\n    }\n    this._validate(\"select\");\n    const fields = this._fields || (this._fields = {});\n    const type = typeof arg;\n    let i, len;\n    if ((\"string\" == type || utils.isArgumentsObject(arg)) && \"number\" == typeof arg.length || Array.isArray(arg)) {\n        if (\"string\" == type) arg = arg.split(/\\s+/);\n        for(i = 0, len = arg.length; i < len; ++i){\n            let field = arg[i];\n            if (!field) continue;\n            const include = \"-\" == field[0] ? 0 : 1;\n            if (include === 0) field = field.substring(1);\n            fields[field] = include;\n        }\n        return this;\n    }\n    if (utils.isObject(arg)) {\n        const keys = utils.keys(arg);\n        for(i = 0; i < keys.length; ++i){\n            fields[keys[i]] = arg[keys[i]];\n        }\n        return this;\n    }\n    throw new TypeError(\"Invalid select() argument. Must be string or object.\");\n};\n/**\n * Specifies a $slice condition for a `path`\n *\n * #### Example:\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @param {String} [path]\n * @param {Number} val number/range of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @api public\n */ Query.prototype.slice = function() {\n    if (0 === arguments.length) return this;\n    this._validate(\"slice\");\n    let path, val;\n    if (1 === arguments.length) {\n        const arg = arguments[0];\n        if (typeof arg === \"object\" && !Array.isArray(arg)) {\n            const keys = Object.keys(arg);\n            const numKeys = keys.length;\n            for(let i = 0; i < numKeys; ++i){\n                this.slice(keys[i], arg[keys[i]]);\n            }\n            return this;\n        }\n        this._ensurePath(\"slice\");\n        path = this._path;\n        val = arguments[0];\n    } else if (2 === arguments.length) {\n        if (\"number\" === typeof arguments[0]) {\n            this._ensurePath(\"slice\");\n            path = this._path;\n            val = [\n                arguments[0],\n                arguments[1]\n            ];\n        } else {\n            path = arguments[0];\n            val = arguments[1];\n        }\n    } else if (3 === arguments.length) {\n        path = arguments[0];\n        val = [\n            arguments[1],\n            arguments[2]\n        ];\n    }\n    const myFields = this._fields || (this._fields = {});\n    myFields[path] = {\n        $slice: val\n    };\n    return this;\n};\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     query.sort({ field: 'asc', test: -1 });\n *     query.sort('field -test');\n *     query.sort([['field', 1], ['test', -1]]);\n *\n * #### Note:\n *\n *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).\n *  - Cannot be used with `distinct()`\n *\n * @param {Object|String|Array} arg\n * @return {Query} this\n * @api public\n */ Query.prototype.sort = function(arg) {\n    if (!arg) return this;\n    let i, len, field;\n    this._validate(\"sort\");\n    const type = typeof arg;\n    // .sort([['field', 1], ['test', -1]])\n    if (Array.isArray(arg)) {\n        len = arg.length;\n        for(i = 0; i < arg.length; ++i){\n            if (!Array.isArray(arg[i])) {\n                throw new Error(\"Invalid sort() argument, must be array of arrays\");\n            }\n            _pushArr(this.options, arg[i][0], arg[i][1]);\n        }\n        return this;\n    }\n    // .sort('field -test')\n    if (1 === arguments.length && \"string\" == type) {\n        arg = arg.split(/\\s+/);\n        len = arg.length;\n        for(i = 0; i < len; ++i){\n            field = arg[i];\n            if (!field) continue;\n            const ascend = \"-\" == field[0] ? -1 : 1;\n            if (ascend === -1) field = field.substring(1);\n            push(this.options, field, ascend);\n        }\n        return this;\n    }\n    // .sort({ field: 1, test: -1 })\n    if (utils.isObject(arg)) {\n        const keys = utils.keys(arg);\n        for(i = 0; i < keys.length; ++i){\n            field = keys[i];\n            push(this.options, field, arg[field]);\n        }\n        return this;\n    }\n    if (typeof Map !== \"undefined\" && arg instanceof Map) {\n        _pushMap(this.options, arg);\n        return this;\n    }\n    throw new TypeError(\"Invalid sort() argument. Must be a string, object, or array.\");\n};\n/*!\n * @ignore\n */ const _validSortValue = {\n    1: 1,\n    \"-1\": -1,\n    asc: 1,\n    ascending: 1,\n    desc: -1,\n    descending: -1\n};\nfunction push(opts, field, value) {\n    if (Array.isArray(opts.sort)) {\n        throw new TypeError(\"Can't mix sort syntaxes. Use either array or object:\" + \"\\n- `.sort([['field', 1], ['test', -1]])`\" + \"\\n- `.sort({ field: 1, test: -1 })`\");\n    }\n    let s;\n    if (value && value.$meta) {\n        s = opts.sort || (opts.sort = {});\n        s[field] = {\n            $meta: value.$meta\n        };\n        return;\n    }\n    s = opts.sort || (opts.sort = {});\n    let val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError(\"Invalid sort value: { \" + field + \": \" + value + \" }\");\n    s[field] = val;\n}\nfunction _pushArr(opts, field, value) {\n    opts.sort = opts.sort || [];\n    if (!Array.isArray(opts.sort)) {\n        throw new TypeError(\"Can't mix sort syntaxes. Use either array or object:\" + \"\\n- `.sort([['field', 1], ['test', -1]])`\" + \"\\n- `.sort({ field: 1, test: -1 })`\");\n    }\n    let val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError(\"Invalid sort value: [ \" + field + \", \" + value + \" ]\");\n    opts.sort.push([\n        field,\n        val\n    ]);\n}\nfunction _pushMap(opts, map) {\n    opts.sort = opts.sort || new Map();\n    if (!(opts.sort instanceof Map)) {\n        throw new TypeError(\"Can't mix sort syntaxes. Use either array or \" + \"object or map consistently\");\n    }\n    map.forEach(function(value, key) {\n        let val = String(value || 1).toLowerCase();\n        val = _validSortValue[val];\n        if (!val) throw new TypeError(\"Invalid sort value: < \" + key + \": \" + value + \" >\");\n        opts.sort.set(key, val);\n    });\n}\n/**\n * Specifies the limit option.\n *\n * #### Example:\n *\n *     query.limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D\n * @api public\n */ /**\n * Specifies the skip option.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D\n * @api public\n */ /**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D\n * @api public\n */ /**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment\n * @api public\n */ /*!\n * limit, skip, batchSize, comment\n *\n * Sets these associated options.\n *\n *     query.comment('feed query');\n */ [\n    \"limit\",\n    \"skip\",\n    \"batchSize\",\n    \"comment\"\n].forEach(function(method) {\n    Query.prototype[method] = function(v) {\n        this._validate(method);\n        this.options[method] = v;\n        return this;\n    };\n});\n/**\n * Specifies the maxTimeMS option.\n *\n * #### Example:\n *\n *     query.maxTime(100)\n *     query.maxTimeMS(100)\n *\n * @method maxTime\n * @memberOf Query\n * @param {Number} ms\n * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS\n * @api public\n */ Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {\n    this._validate(\"maxTime\");\n    this.options.maxTimeMS = ms;\n    return this;\n};\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1});\n *     query.hint('indexA_1_indexB_1');\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|string} val a hint object or the index name\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint\n * @api public\n */ Query.prototype.hint = function() {\n    if (0 === arguments.length) return this;\n    this._validate(\"hint\");\n    const arg = arguments[0];\n    if (utils.isObject(arg)) {\n        const hint = this.options.hint || (this.options.hint = {});\n        // must keep object keys in order so don't use Object.keys()\n        for(const k in arg){\n            hint[k] = arg[k];\n        }\n        return this;\n    }\n    if (typeof arg === \"string\") {\n        this.options.hint = arg;\n        return this;\n    }\n    throw new TypeError(\"Invalid hint. \" + arg);\n};\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `j` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */ Query.prototype.j = function j(val) {\n    this.options.j = val;\n    return this;\n};\n/**\n * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.\n *\n * #### Example:\n *\n *     query.slaveOk() // true\n *     query.slaveOk(true)\n *     query.slaveOk(false)\n *\n * @deprecated use read() preferences instead if on mongodb >= 2.2\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see read()\n * @return {Query} this\n * @api public\n */ Query.prototype.slaveOk = function(v) {\n    this.options.slaveOk = arguments.length ? !!v : true;\n    return this;\n};\n/**\n * Sets the readPreference option for the query.\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // you can also use mongodb.ReadPreference class to also specify tags\n *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))\n *\n *     new Query().setReadPreference('primary') // alias of .read()\n *\n * #### Preferences:\n *\n *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */ Query.prototype.read = Query.prototype.setReadPreference = function(pref) {\n    if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {\n        console.error(\"Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.\");\n        Query.prototype.read.deprecationWarningIssued = true;\n    }\n    this.options.readPreference = utils.readPref(pref);\n    return this;\n};\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *     new Query().r('s') // r is alias of readConcern\n *\n *\n * #### Read Concern Level:\n *\n *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n *\n * Aliases\n *\n *     l   local\n *     a   available\n *     m   majority\n *     lz  linearizable\n *     s   snapshot\n *\n * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */ Query.prototype.readConcern = Query.prototype.r = function(level) {\n    this.options.readConcern = utils.readConcern(level);\n    return this;\n};\n/**\n * Sets tailable option.\n *\n * #### Example:\n *\n *     query.tailable() <== true\n *     query.tailable(true)\n *     query.tailable(false)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} v defaults to true\n * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors\n * @api public\n */ Query.prototype.tailable = function() {\n    this._validate(\"tailable\");\n    this.options.tailable = arguments.length ? !!arguments[0] : true;\n    return this;\n};\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `w` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().writeConcern(0)\n *     mquery().writeConcern(1)\n *     mquery().writeConcern({ w: 1, j: true, wtimeout: 2000 })\n *     mquery().writeConcern('majority')\n *     mquery().writeConcern('m') // same as majority\n *     mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern({ w: 'm' }) instead\n *     mquery().w(1) // w is alias of writeConcern\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {String|number|object} concern 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */ Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {\n    if (\"object\" === typeof concern) {\n        if (\"undefined\" !== typeof concern.j) this.options.j = concern.j;\n        if (\"undefined\" !== typeof concern.w) this.options.w = concern.w;\n        if (\"undefined\" !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;\n    } else {\n        this.options.w = \"m\" === concern ? \"majority\" : concern;\n    }\n    return this;\n};\n/**\n * Specifies a time limit, in milliseconds, for the write concern.\n * If `ms > 1`, it is maximum amount of time to wait for this write\n * to propagate through the replica set before this operation fails.\n * The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to `wtimeout` value if it is specified in writeConcern\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000)\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */ Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {\n    this.options.wtimeout = ms;\n    return this;\n};\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */ Query.prototype.merge = function(source) {\n    if (!source) return this;\n    if (!Query.canMerge(source)) throw new TypeError(\"Invalid argument. Expected instanceof mquery or plain object\");\n    if (source instanceof Query) {\n        // if source has a feature, apply it to ourselves\n        if (source._conditions) {\n            utils.merge(this._conditions, source._conditions);\n        }\n        if (source._fields) {\n            this._fields || (this._fields = {});\n            utils.merge(this._fields, source._fields);\n        }\n        if (source.options) {\n            this.options || (this.options = {});\n            utils.merge(this.options, source.options);\n        }\n        if (source._updateDoc) {\n            this._updateDoc || (this._updateDoc = {});\n            utils.mergeClone(this._updateDoc, source._updateDoc);\n        }\n        if (source._distinctDoc) {\n            this._distinctDoc = source._distinctDoc;\n        }\n        return this;\n    }\n    // plain object\n    utils.merge(this._conditions, source);\n    return this;\n};\n/**\n * Finds documents.\n *\n * #### Example:\n *\n *     query.find()\n *     await query.find()\n *     await query.find({ name: 'Burning Lights' })\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.find = function(criteria) {\n    this.op = \"find\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `find` Query\n * @returns the result\n */ Query.prototype._find = async function _find() {\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"_find\", this._collection.collectionName, conds, options);\n    return this._collection.find(conds, options);\n};\n/**\n * Returns the query cursor\n *\n * #### Examples:\n *\n *     query.find().cursor();\n *     query.cursor({ name: 'Burning Lights' });\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Object} cursor\n * @api public\n */ Query.prototype.cursor = function cursor(criteria) {\n    if (this.op) {\n        if (this.op !== \"find\") {\n            throw new TypeError(\".cursor only support .find method\");\n        }\n    } else {\n        this.find(criteria);\n    }\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"findCursor\", this._collection.collectionName, conds, options);\n    return this._collection.findCursor(conds, options);\n};\n/**\n * Executes the query as a findOne() operation.\n *\n * #### Example:\n *\n *     query.findOne().where('name', /^Burning/);\n *\n *     query.findOne({ name: /^Burning/ })\n *\n *     await query.findOne({ name: /^Burning/ }); // executes\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.findOne = function(criteria) {\n    this.op = \"findOne\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `findOne` Query\n * @returns the results\n */ Query.prototype._findOne = async function _findOne() {\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"findOne\", this._collection.collectionName, conds, options);\n    return this._collection.findOne(conds, options);\n};\n/**\n * Exectues the query as a count() operation.\n *\n * #### Example:\n *\n *     query.count().where('color', 'black').exec();\n *\n *     query.count({ color: 'black' })\n *\n *     await query.count({ color: 'black' });\n *\n *     const doc = await query.where('color', 'black').count();\n *     console.log('there are %d kittens', count);\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count\n * @api public\n */ Query.prototype.count = function(criteria) {\n    this.op = \"count\";\n    this._validate();\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `count` Query\n * @returns the results\n */ Query.prototype._count = async function _count() {\n    const conds = this._conditions, options = this._optionsForExec();\n    debug(\"count\", this._collection.collectionName, conds, options);\n    return this._collection.count(conds, options);\n};\n/**\n * Declares or executes a distinct() operation.\n *\n * #### Example:\n *\n *     await distinct(criteria, field)\n *     distinct(criteria, field)\n *     await distinct(field)\n *     distinct(field)\n *     await distinct()\n *     distinct()\n *\n * @param {Object|Query} [criteria]\n * @param {String} [field]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct\n * @api public\n */ Query.prototype.distinct = function(criteria, field) {\n    this.op = \"distinct\";\n    this._validate();\n    if (!field && typeof criteria === \"string\") {\n        field = criteria;\n        criteria = undefined;\n    }\n    if (\"string\" == typeof field) {\n        this._distinctDoc = field;\n    }\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `distinct` Query\n * @returns the results\n */ Query.prototype._distinct = async function _distinct() {\n    if (!this._distinctDoc) {\n        throw new Error(\"No value for `distinct` has been declared\");\n    }\n    const conds = this._conditions, options = this._optionsForExec();\n    debug(\"distinct\", this._collection.collectionName, conds, options);\n    return this._collection.distinct(this._distinctDoc, conds, options);\n};\n/**\n * Declare and/or execute this query as an `updateMany()` operation. This function will update _all_ documents that match\n * `criteria`, rather than just the first one.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update every document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */ Query.prototype.updateMany = function updateMany(criteria, doc, options) {\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    return _update(this, \"updateMany\", criteria, doc, options);\n};\n/**\n * Executes a `updateMany` Query\n * @returns the results\n */ Query.prototype._updateMany = async function() {\n    return _updateExec(this, \"updateMany\");\n};\n/**\n * Declare and/or execute this query as an `updateOne()` operation. This function will _always_ update just one document,\n * regardless of the `multi` option.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update the first document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */ Query.prototype.updateOne = function updateOne(criteria, doc, options) {\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    return _update(this, \"updateOne\", criteria, doc, options);\n};\n/**\n * Executes a `updateOne` Query\n * @returns the results\n */ Query.prototype._updateOne = async function() {\n    return _updateExec(this, \"updateOne\");\n};\n/**\n * Declare and/or execute this query as an `replaceOne()` operation. Similar\n * to `updateOne()`, except `replaceOne()` is not allowed to use atomic\n * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always\n * replace the existing doc.\n *\n * #### Example:\n *\n *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 }`\n *     mquery().replaceOne({ _id: 1 }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */ Query.prototype.replaceOne = function replaceOne(criteria, doc, options) {\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    this.setOptions({\n        overwrite: true\n    });\n    return _update(this, \"replaceOne\", criteria, doc, options);\n};\n/**\n * Executes a `replaceOne` Query\n * @returns the results\n */ Query.prototype._replaceOne = async function() {\n    return _updateExec(this, \"replaceOne\");\n};\n/*!\n * Internal helper for updateMany, updateOne\n */ function _update(query, op, criteria, doc, options) {\n    query.op = op;\n    if (Query.canMerge(criteria)) {\n        query.merge(criteria);\n    }\n    if (doc) {\n        query._mergeUpdate(doc);\n    }\n    if (utils.isObject(options)) {\n        // { overwrite: true }\n        query.setOptions(options);\n    }\n    return query;\n}\n/**\n * Helper for de-duplicating \"update*\" functions\n * @param {Query} query The Query Object (replacement for \"this\")\n * @param {String} op The Operation to be done\n * @returns the results\n */ async function _updateExec(query, op) {\n    const options = query._optionsForExec();\n    const criteria = query._conditions;\n    const doc = query._updateForExec();\n    debug(\"update\", query._collection.collectionName, criteria, doc, options);\n    return query._collection[op](criteria, doc, options);\n}\n/**\n * Declare and/or execute this query as a `deleteOne()` operation.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteOne({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.deleteOne = function(criteria) {\n    this.op = \"deleteOne\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `deleteOne` Query\n * @returns the results\n */ Query.prototype._deleteOne = async function() {\n    const options = this._optionsForExec();\n    delete options.justOne;\n    const conds = this._conditions;\n    debug(\"deleteOne\", this._collection.collectionName, conds, options);\n    return this._collection.deleteOne(conds, options);\n};\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Always deletes\n * _every_ document that matches `criteria`.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteMany({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.deleteMany = function(criteria) {\n    this.op = \"deleteMany\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `deleteMany` Query\n * @returns the results\n */ Query.prototype._deleteMany = async function() {\n    const options = this._optionsForExec();\n    delete options.justOne;\n    const conds = this._conditions;\n    debug(\"deleteOne\", this._collection.collectionName, conds, options);\n    return this._collection.deleteMany(conds, options);\n};\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).\n *\n * #### Available options\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await query.findOneAndUpdate(conditions, update, options) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     await query.findOneAndUpdate(conditions, update) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     await query.findOneAndUpdate(update)             // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     await query.findOneAndUpdate()                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @param {Object|Query} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @return {Query} this\n * @api public\n */ Query.prototype.findOneAndUpdate = function(criteria, doc, options) {\n    this.op = \"findOneAndUpdate\";\n    this._validate();\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    // apply doc\n    if (doc) {\n        this._mergeUpdate(doc);\n    }\n    options && this.setOptions(options);\n    return this;\n};\n/**\n * Executes a `findOneAndUpdate` Query\n * @returns the results\n */ Query.prototype._findOneAndUpdate = async function() {\n    const conds = this._conditions;\n    const update = this._updateForExec();\n    const options = this._optionsForExec();\n    return this._collection.findOneAndUpdate(conds, update, options);\n};\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, returning the found document (if any).\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await A.where().findOneAndRemove(conditions, options) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     await A.where().findOneAndRemove(conditions) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     await A.where().findOneAndRemove()   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *     A.where().findOneAndDelete()           // alias of .findOneAndRemove()\n *\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */ Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options) {\n    this.op = \"findOneAndRemove\";\n    this._validate();\n    // apply conditions\n    if (Query.canMerge(conditions)) {\n        this.merge(conditions);\n    }\n    // apply options\n    options && this.setOptions(options);\n    return this;\n};\n/**\n * Executes a `findOneAndRemove` Query\n * @returns the results\n */ Query.prototype._findOneAndRemove = async function() {\n    const options = this._optionsForExec();\n    const conds = this._conditions;\n    return this._collection.findOneAndDelete(conds, options);\n};\n/**\n * Add trace function that gets called when the query is executed.\n * The function will be called with (method, queryInfo, query) and\n * should return a callback function which will be called\n * with (err, result, millis) when the query is complete.\n *\n * queryInfo is an object containing: {\n *   collectionName: <name of the collection>,\n *   conditions: <query criteria>,\n *   options: <comment, fields, readPreference, etc>,\n *   doc: [document to update, if applicable]\n * }\n *\n * NOTE: Does not trace stream queries.\n *\n * @param {Function} traceFunction\n * @return {Query} this\n * @api public\n */ Query.prototype.setTraceFunction = function(traceFunction) {\n    this._traceFunction = traceFunction;\n    return this;\n};\n/**\n * Executes the query\n *\n * #### Examples:\n *\n *     query.exec();\n *     await query.exec();\n *     query.exec('update');\n *     await query.exec('find');\n *\n * @param {String|Function} [operation]\n * @api public\n */ Query.prototype.exec = async function exec(op) {\n    if (typeof op === \"string\") {\n        this.op = op;\n    }\n    assert.ok(this.op, \"Missing query type: (find, etc)\");\n    const fnName = \"_\" + this.op;\n    // better error, because default would list it as \"this[fnName] is not a function\"\n    if (typeof this[fnName] !== \"function\") {\n        throw new TypeError(`this[${fnName}] is not a function`);\n    }\n    return this[fnName]();\n};\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */ Query.prototype.then = async function(res, rej) {\n    return this.exec().then(res, rej);\n};\n/**\n * Returns a cursor for the given `find` query.\n *\n * @throws Error if operation is not a find\n * @returns {Cursor} MongoDB driver cursor\n */ Query.prototype.cursor = function() {\n    if (\"find\" != this.op) throw new Error(\"cursor() is only available for find\");\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"cursor\", this._collection.collectionName, conds, options);\n    return this._collection.findCursor(conds, options);\n};\n/**\n * Determines if field selection has been made.\n *\n * @return {Boolean}\n * @api public\n */ Query.prototype.selected = function selected() {\n    return !!(this._fields && Object.keys(this._fields).length > 0);\n};\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively() // false\n *     query.select('name')\n *     query.selectedInclusively() // true\n *     query.selectedExlusively() // false\n *\n * @returns {Boolean}\n */ Query.prototype.selectedInclusively = function selectedInclusively() {\n    if (!this._fields) return false;\n    const keys = Object.keys(this._fields);\n    if (0 === keys.length) return false;\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (0 === this._fields[key]) return false;\n        if (this._fields[key] && typeof this._fields[key] === \"object\" && this._fields[key].$meta) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExlusively() // false\n *     query.select('-name')\n *     query.selectedExlusively() // true\n *     query.selectedInclusively() // false\n *\n * @returns {Boolean}\n */ Query.prototype.selectedExclusively = function selectedExclusively() {\n    if (!this._fields) return false;\n    const keys = Object.keys(this._fields);\n    if (0 === keys.length) return false;\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (0 === this._fields[key]) return true;\n    }\n    return false;\n};\n/**\n * Merges `doc` with the current update object.\n *\n * @param {Object} doc\n */ Query.prototype._mergeUpdate = function(doc) {\n    if (!this._updateDoc) this._updateDoc = {};\n    if (doc instanceof Query) {\n        if (doc._updateDoc) {\n            utils.mergeClone(this._updateDoc, doc._updateDoc);\n        }\n    } else {\n        utils.mergeClone(this._updateDoc, doc);\n    }\n};\n/**\n * Returns default options.\n *\n * @return {Object}\n * @api private\n */ Query.prototype._optionsForExec = function() {\n    const options = utils.clone(this.options);\n    return options;\n};\n/**\n * Returns fields selection for this query.\n *\n * @return {Object}\n * @api private\n */ Query.prototype._fieldsForExec = function() {\n    return utils.clone(this._fields);\n};\n/**\n * Return an update document with corrected $set operations.\n *\n * @api private\n */ Query.prototype._updateForExec = function() {\n    const update = utils.clone(this._updateDoc);\n    const ops = utils.keys(update);\n    const ret = {};\n    for (const op of ops){\n        if (this.options.overwrite) {\n            ret[op] = update[op];\n            continue;\n        }\n        if (\"$\" !== op[0]) {\n            // fix up $set sugar\n            if (!ret.$set) {\n                if (update.$set) {\n                    ret.$set = update.$set;\n                } else {\n                    ret.$set = {};\n                }\n            }\n            ret.$set[op] = update[op];\n            if (!~ops.indexOf(\"$set\")) ops.push(\"$set\");\n        } else if (\"$set\" === op) {\n            if (!ret.$set) {\n                ret[op] = update[op];\n            }\n        } else {\n            ret[op] = update[op];\n        }\n    }\n    this._compiledUpdate = ret;\n    return ret;\n};\n/**\n * Make sure _path is set.\n *\n * @parmam {String} method\n */ Query.prototype._ensurePath = function(method) {\n    if (!this._path) {\n        const msg = method + \"() must be used after where() \" + \"when called with these arguments\";\n        throw new Error(msg);\n    }\n};\n/*!\n * Permissions\n */ Query.permissions = __webpack_require__(/*! ./permissions */ \"(ssr)/./node_modules/mquery/lib/permissions.js\");\nQuery._isPermitted = function(a, b) {\n    const denied = Query.permissions[b];\n    if (!denied) return true;\n    return true !== denied[a];\n};\nQuery.prototype._validate = function(action) {\n    let fail;\n    let validator;\n    if (undefined === action) {\n        validator = Query.permissions[this.op];\n        if (\"function\" != typeof validator) return true;\n        fail = validator(this);\n    } else if (!Query._isPermitted(action, this.op)) {\n        fail = action;\n    }\n    if (fail) {\n        throw new Error(fail + \" cannot be used with \" + this.op);\n    }\n};\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @param {Object} conds\n * @return {Boolean}\n */ Query.canMerge = function(conds) {\n    return conds instanceof Query || utils.isObject(conds);\n};\n/**\n * Set a trace function that will get called whenever a\n * query is executed.\n *\n * See `setTraceFunction()` for details.\n *\n * @param {Object} conds\n * @return {Boolean}\n */ Query.setGlobalTraceFunction = function(traceFunction) {\n    Query.traceFunction = traceFunction;\n};\n/*!\n * Exports.\n */ Query.utils = utils;\nQuery.env = __webpack_require__(/*! ./env */ \"(ssr)/./node_modules/mquery/lib/env.js\");\nQuery.Collection = __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/index.js\");\nQuery.BaseCollection = __webpack_require__(/*! ./collection/collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\");\nmodule.exports = exports = Query; // TODO\n // test utils\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9tcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Q0FFQyxHQUVELE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1HLFFBQVFILG1CQUFPQSxDQUFDLHdEQUFTO0FBRS9COzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVELFNBQVNJLE1BQU1DLFFBQVEsRUFBRUMsT0FBTztJQUM5QixJQUFJLENBQUUsS0FBSSxZQUFZRixLQUFJLEdBQ3hCLE9BQU8sSUFBSUEsTUFBTUMsVUFBVUM7SUFFN0IsTUFBTUMsUUFBUSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsU0FBUztJQUV4QyxJQUFJLENBQUNDLEVBQUUsR0FBR0gsTUFBTUcsRUFBRSxJQUFJQztJQUV0QixJQUFJLENBQUNMLE9BQU8sR0FBR00sT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR04sTUFBTUQsT0FBTztJQUU5QyxJQUFJLENBQUNRLFdBQVcsR0FBR1AsTUFBTU8sV0FBVyxHQUNoQ1osTUFBTWEsS0FBSyxDQUFDUixNQUFNTyxXQUFXLElBQzdCLENBQUM7SUFFTCxJQUFJLENBQUNFLE9BQU8sR0FBR1QsTUFBTVMsT0FBTyxHQUN4QmQsTUFBTWEsS0FBSyxDQUFDUixNQUFNUyxPQUFPLElBQ3pCTDtJQUVKLElBQUksQ0FBQ00sVUFBVSxHQUFHVixNQUFNVSxVQUFVLEdBQzlCZixNQUFNYSxLQUFLLENBQUNSLE1BQU1VLFVBQVUsSUFDNUJOO0lBRUosSUFBSSxDQUFDTyxLQUFLLEdBQUdYLE1BQU1XLEtBQUssSUFBSVA7SUFDNUIsSUFBSSxDQUFDUSxZQUFZLEdBQUdaLE1BQU1ZLFlBQVksSUFBSVI7SUFDMUMsSUFBSSxDQUFDUyxXQUFXLEdBQUdiLE1BQU1hLFdBQVcsSUFBSVQ7SUFDeEMsSUFBSSxDQUFDVSxjQUFjLEdBQUdkLE1BQU1j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MEMsVUFBVSxHQUFHOUMsbUJBQU9BLENBQUM7QUFDM0JJLE1BQU1rTyxjQUFjLEdBQUd0TyxtQkFBT0EsQ0FBQztBQUMvQnVPLE9BQU9DLE9BQU8sR0FBR0EsVUFBVXBPLE9BRTNCLE9BQU87Q0FDUCxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWRtaW4vLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9tcXVlcnkuanM/N2I1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21xdWVyeScpO1xuXG4vKipcbiAqIFF1ZXJ5IGNvbnN0cnVjdG9yIHVzZWQgZm9yIGJ1aWxkaW5nIHF1ZXJpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkoeyBuYW1lOiAnbXF1ZXJ5JyB9KTtcbiAqICAgICBxdWVyeS5zZXRPcHRpb25zKHsgY29sbGVjdGlvbjogbW9kdWxlQ29sbGVjdGlvbiB9KVxuICogICAgIGF3YWl0IHF1ZXJ5LndoZXJlKCdhZ2UnKS5ndGUoMjEpLmV4ZWMoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXSBjcml0ZXJpYSBmb3IgdGhlIHF1ZXJ5IE9SIHRoZSBjb2xsZWN0aW9uIGluc3RhbmNlIHRvIHVzZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBRdWVyeShjcml0ZXJpYSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUXVlcnkpKVxuICAgIHJldHVybiBuZXcgUXVlcnkoY3JpdGVyaWEsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IHByb3RvID0gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgdGhpcy5vcCA9IHByb3RvLm9wIHx8IHVuZGVmaW5lZDtcblxuICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm90by5vcHRpb25zKTtcblxuICB0aGlzLl9jb25kaXRpb25zID0gcHJvdG8uX2NvbmRpdGlvbnNcbiAgICA/IHV0aWxzLmNsb25lKHByb3RvLl9jb25kaXRpb25zKVxuICAgIDoge307XG5cbiAgdGhpcy5fZmllbGRzID0gcHJvdG8uX2ZpZWxkc1xuICAgID8gdXRpbHMuY2xvbmUocHJvdG8uX2ZpZWxkcylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB0aGlzLl91cGRhdGVEb2MgPSBwcm90by5fdXBkYXRlRG9jXG4gICAgPyB1dGlscy5jbG9uZShwcm90by5fdXBkYXRlRG9jKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHRoaXMuX3BhdGggPSBwcm90by5fcGF0aCB8fCB1bmRlZmluZWQ7XG4gIHRoaXMuX2Rpc3RpbmN0RG9jID0gcHJvdG8uX2Rpc3RpbmN0RG9jIHx8IHVuZGVmaW5lZDtcbiAgdGhpcy5fY29sbGVjdGlvbiA9IHByb3RvLl9jb2xsZWN0aW9uIHx8IHVuZGVmaW5lZDtcbiAgdGhpcy5fdHJhY2VGdW5jdGlvbiA9IHByb3RvLl90cmFjZUZ1bmN0aW9uIHx8IHVuZGVmaW5lZDtcblxuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChjcml0ZXJpYSkge1xuICAgIHRoaXMuZmluZChjcml0ZXJpYSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgcGFyYW1ldGVyIHRoYXQgdGhlIHVzZXIgY2FuIHNldCB3aGljaCBkZXRlcm1pbmVzIGlmIG1xdWVyeVxuICogdXNlcyAkd2l0aGluIG9yICRnZW9XaXRoaW4gZm9yIHF1ZXJpZXMuIEl0IGRlZmF1bHRzIHRvIHRydWUgd2hpY2hcbiAqIG1lYW5zICRnZW9XaXRoaW4gd2lsbCBiZSB1c2VkLiBJZiB1c2luZyBNb25nb0RCIDwgMi40IHlvdSBzaG91bGRcbiAqIHNldCB0aGlzIHRvIGZhbHNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdXNlJGdlb1dpdGhpblxuICovXG5cbmxldCAkd2l0aGluQ21kID0gJyRnZW9XaXRoaW4nO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5LCAndXNlJGdlb1dpdGhpbicsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuICR3aXRoaW5DbWQgPT0gJyRnZW9XaXRoaW4nOyB9LFxuICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodHJ1ZSA9PT0gdikge1xuICAgICAgLy8gbW9uZ29kYiA+PSAyLjRcbiAgICAgICR3aXRoaW5DbWQgPSAnJGdlb1dpdGhpbic7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3aXRoaW5DbWQgPSAnJHdpdGhpbic7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIHF1ZXJ5IHRvIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gd2l0aCBhbGwgYXJndW1lbnRzIGFuZCBvcHRpb25zIHJldGFpbmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgcXVlcnkgdGhhdCB3aWxsIHJlYWQgZG9jdW1lbnRzIHdpdGggYSBcInZpZGVvXCIgY2F0ZWdvcnkgZnJvbVxuICogICAgIC8vIGBhQ29sbGVjdGlvbmAgb24gdGhlIHByaW1hcnkgbm9kZSBpbiB0aGUgcmVwbGljYS1zZXQgdW5sZXNzIGl0IGlzIGRvd24sXG4gKiAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSdsbCByZWFkIGZyb20gYSBzZWNvbmRhcnkgbm9kZS5cbiAqICAgICB2YXIgcXVlcnkgPSBtcXVlcnkoeyBjYXRlZ29yeTogJ3ZpZGVvJyB9KVxuICogICAgIHF1ZXJ5LnNldE9wdGlvbnMoeyBjb2xsZWN0aW9uOiBhQ29sbGVjdGlvbiwgcmVhZDogJ3ByaW1hcnlQcmVmZXJyZWQnIH0pO1xuICpcbiAqICAgICAvLyBjcmVhdGUgYSBjb25zdHJ1Y3RvciBiYXNlZCBvZmYgdGhlc2Ugc2V0dGluZ3NcbiAqICAgICB2YXIgVmlkZW8gPSBxdWVyeS50b0NvbnN0cnVjdG9yKCk7XG4gKlxuICogICAgIC8vIFZpZGVvIGlzIG5vdyBhIHN1YmNsYXNzIG9mIG1xdWVyeSgpIGFuZCB3b3JrcyB0aGUgc2FtZSB3YXkgYnV0IHdpdGggdGhlXG4gKiAgICAgLy8gZGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIGFuZCBvcHRpb25zIHNldC5cbiAqXG4gKiAgICAgLy8gcnVuIGEgcXVlcnkgd2l0aCB0aGUgcHJldmlvdXMgc2V0dGluZ3MgYnV0IGZpbHRlciBmb3IgbW92aWVzIHdpdGggbmFtZXNcbiAqICAgICAvLyB0aGF0IHN0YXJ0IHdpdGggXCJMaWZlXCIuXG4gKiAgICAgVmlkZW8oKS53aGVyZSh7IG5hbWU6IC9eTGlmZS8gfSkuZXhlYyhjYik7XG4gKlxuICogQHJldHVybiB7UXVlcnl9IG5ldyBRdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudG9Db25zdHJ1Y3RvciA9IGZ1bmN0aW9uIHRvQ29uc3RydWN0b3IoKSB7XG4gIGZ1bmN0aW9uIEN1c3RvbVF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbVF1ZXJ5KSlcbiAgICAgIHJldHVybiBuZXcgQ3VzdG9tUXVlcnkoY3JpdGVyaWEsIG9wdGlvbnMpO1xuICAgIFF1ZXJ5LmNhbGwodGhpcywgY3JpdGVyaWEsIG9wdGlvbnMpO1xuICB9XG5cbiAgdXRpbHMuaW5oZXJpdHMoQ3VzdG9tUXVlcnksIFF1ZXJ5KTtcblxuICAvLyBzZXQgaW5oZXJpdGVkIGRlZmF1bHRzXG4gIGNvbnN0IHAgPSBDdXN0b21RdWVyeS5wcm90b3R5cGU7XG5cbiAgcC5vcHRpb25zID0ge307XG4gIHAuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuXG4gIHAub3AgPSB0aGlzLm9wO1xuICBwLl9jb25kaXRpb25zID0gdXRpbHMuY2xvbmUodGhpcy5fY29uZGl0aW9ucyk7XG4gIHAuX2ZpZWxkcyA9IHV0aWxzLmNsb25lKHRoaXMuX2ZpZWxkcyk7XG4gIHAuX3VwZGF0ZURvYyA9IHV0aWxzLmNsb25lKHRoaXMuX3VwZGF0ZURvYyk7XG4gIHAuX3BhdGggPSB0aGlzLl9wYXRoO1xuICBwLl9kaXN0aW5jdERvYyA9IHRoaXMuX2Rpc3RpbmN0RG9jO1xuICBwLl9jb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgcC5fdHJhY2VGdW5jdGlvbiA9IHRoaXMuX3RyYWNlRnVuY3Rpb247XG5cbiAgcmV0dXJuIEN1c3RvbVF1ZXJ5O1xufTtcblxuLyoqXG4gKiBTZXRzIHF1ZXJ5IG9wdGlvbnMuXG4gKlxuICogIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gW3RhaWxhYmxlXShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9UYWlsYWJsZStDdXJzb3JzKSAqXG4gKiAtIFtzb3J0XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0Jzb3J0KFxcKSU3RCU3RCkgKlxuICogLSBbbGltaXRdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QmxpbWl0JTI4JTI5JTdEJTdEKSAqXG4gKiAtIFtza2lwXShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0Jza2lwJTI4JTI5JTdEJTdEKSAqXG4gKiAtIFttYXhUaW1lXShodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21ldGEvbWF4VGltZU1TLyNvcC5fU19tYXhUaW1lTVMpICpcbiAqIC0gW2JhdGNoU2l6ZV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCYmF0Y2hTaXplJTI4JTI5JTdEJTdEKSAqXG4gKiAtIFtjb21tZW50XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lMjRjb21tZW50KSAqXG4gKiAtIFtoaW50XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lMjRoaW50KSAqXG4gKiAtIFtzbGF2ZU9rXShodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2UpICpcbiAqIC0gW3NhZmVdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2dldExhc3RFcnJvcitDb21tYW5kKVxuICogLSBjb2xsZWN0aW9uIHRoZSBjb2xsZWN0aW9uIHRvIHF1ZXJ5IGFnYWluc3RcbiAqXG4gKiBfKiBkZW5vdGVzIGEgcXVlcnkgaGVscGVyIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZV9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKCEob3B0aW9ucyAmJiB1dGlscy5pc09iamVjdChvcHRpb25zKSkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gc2V0IGFyYml0cmFyeSBvcHRpb25zXG4gIGNvbnN0IG1ldGhvZHMgPSB1dGlscy5rZXlzKG9wdGlvbnMpO1xuICBsZXQgbWV0aG9kO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSkge1xuICAgIG1ldGhvZCA9IG1ldGhvZHNbaV07XG5cbiAgICAvLyB1c2UgbWV0aG9kcyBpZiBleGlzdCAoc2FmZXIgb3B0aW9uIG1hbmlwdWxhdGlvbilcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdGhpc1ttZXRob2RdKSB7XG4gICAgICBjb25zdCBhcmdzID0gQXJyYXkuaXNBcnJheShvcHRpb25zW21ldGhvZF0pXG4gICAgICAgID8gb3B0aW9uc1ttZXRob2RdXG4gICAgICAgIDogW29wdGlvbnNbbWV0aG9kXV07XG4gICAgICB0aGlzW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9uc1ttZXRob2RdID0gb3B0aW9uc1ttZXRob2RdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoaXMgUXVlcnlzIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtDb2xsZWN0aW9ufSBjb2xsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jb2xsZWN0aW9uID0gZnVuY3Rpb24gY29sbGVjdGlvbihjb2xsKSB7XG4gIHRoaXMuX2NvbGxlY3Rpb24gPSBuZXcgUXVlcnkuQ29sbGVjdGlvbihjb2xsKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGNvbGxhdGlvbiB0byB0aGlzIG9wIChNb25nb0RCIDMuNCBhbmQgdXApXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5maW5kKCkuY29sbGF0aW9uKHsgbG9jYWxlOiBcImVuX1VTXCIsIHN0cmVuZ3RoOiAxIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBNb25nb0RCIGRvY3MgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5jb2xsYXRpb24vI2N1cnNvci5jb2xsYXRpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvbGxhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkd2hlcmVgIGNvbmRpdGlvblxuICpcbiAqIFVzZSBgJHdoZXJlYCB3aGVuIHlvdSBuZWVkIHRvIHNlbGVjdCBkb2N1bWVudHMgdXNpbmcgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS4kd2hlcmUoJ3RoaXMuY29tbWVudHMubGVuZ3RoID4gMTAgfHwgdGhpcy5uYW1lLmxlbmd0aCA+IDUnKVxuICpcbiAqICAgICBxdWVyeS4kd2hlcmUoZnVuY3Rpb24gKCkge1xuICogICAgICAgcmV0dXJuIHRoaXMuY29tbWVudHMubGVuZ3RoID4gMTAgfHwgdGhpcy5uYW1lLmxlbmd0aCA+IDU7XG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0ganMgamF2YXNjcmlwdCBzdHJpbmcgb3IgZnVuY3Rpb25cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBtZXRob2QgJHdoZXJlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS4kd2hlcmUgPSBmdW5jdGlvbihqcykge1xuICB0aGlzLl9jb25kaXRpb25zLiR3aGVyZSA9IGpzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYHBhdGhgIGZvciB1c2Ugd2l0aCBjaGFpbmluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluc3RlYWQgb2Ygd3JpdGluZzpcbiAqICAgICBhd2FpdCBVc2VyLmZpbmQoe2FnZTogeyRndGU6IDIxLCAkbHRlOiA2NX19KTtcbiAqXG4gKiAgICAgLy8gd2UgY2FuIGluc3RlYWQgd3JpdGU6XG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpO1xuICpcbiAqICAgICAvLyBwYXNzaW5nIHF1ZXJ5IGNvbmRpdGlvbnMgaXMgcGVybWl0dGVkXG4gKiAgICAgVXNlci5maW5kKCkud2hlcmUoeyBuYW1lOiAndm9uZGVyZnVsJyB9KVxuICpcbiAqICAgICAvLyBjaGFpbmluZ1xuICogICAgIGF3YWl0IFVzZXJcbiAqICAgICAgIC53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpXG4gKiAgICAgICAud2hlcmUoJ25hbWUnLCAvXnZvbmRlcmZ1bC9pKVxuICogICAgICAgLndoZXJlKCdmcmllbmRzJykuc2xpY2UoMTApXG4gKiAgICAgICAuZXhlYygpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IFt2YWxdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcztcbiAgaWYgKCF0aGlzLm9wKSB0aGlzLm9wID0gJ2ZpbmQnO1xuXG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJndW1lbnRzWzBdO1xuXG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlKSB7XG4gICAgdGhpcy5fcGF0aCA9IGFyZ3VtZW50c1swXTtcblxuICAgIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9jb25kaXRpb25zW3RoaXMuX3BhdGhdID0gYXJndW1lbnRzWzFdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKCdvYmplY3QnID09IHR5cGUgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgIHJldHVybiB0aGlzLm1lcmdlKGFyZ3VtZW50c1swXSk7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3Igb2JqZWN0Jyk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgY29tcGxlbWVudGFyeSBjb21wYXJpc29uIHZhbHVlIGZvciBwYXRocyBzcGVjaWZpZWQgd2l0aCBgd2hlcmUoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScpLmVxdWFscyg0OSk7XG4gKlxuICogICAgIC8vIGlzIHRoZSBzYW1lIGFzXG4gKlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScsIDQ5KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKHZhbCkge1xuICB0aGlzLl9lbnN1cmVQYXRoKCdlcXVhbHMnKTtcbiAgY29uc3QgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGNvbXBsZW1lbnRhcnkgY29tcGFyaXNvbiB2YWx1ZSBmb3IgcGF0aHMgc3BlY2lmaWVkIHdpdGggYHdoZXJlKClgXG4gKiBUaGlzIGlzIGFsaWFzIG9mIGBlcXVhbHNgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnKS5lcSg0OSk7XG4gKlxuICogICAgIC8vIGlzIHRoZSBzYW1lIGFzXG4gKlxuICogICAgIFVzZXIuc2hlcmUoJ2FnZScpLmVxdWFscyg0OSk7XG4gKlxuICogICAgIC8vIGlzIHRoZSBzYW1lIGFzXG4gKlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScsIDQ5KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSh2YWwpIHtcbiAgdGhpcy5fZW5zdXJlUGF0aCgnZXEnKTtcbiAgY29uc3QgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhbiBgJG9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5vcihbeyBjb2xvcjogJ3JlZCcgfSwgeyBzdGF0dXM6ICdlbWVyZ2VuY3knIH1dKVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IGFycmF5IG9mIGNvbmRpdGlvbnNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKGFycmF5KSB7XG4gIGNvbnN0IG9yID0gdGhpcy5fY29uZGl0aW9ucy4kb3IgfHwgKHRoaXMuX2NvbmRpdGlvbnMuJG9yID0gW10pO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSBhcnJheSA9IFthcnJheV07XG4gIG9yLnB1c2guYXBwbHkob3IsIGFycmF5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGEgYCRub3JgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5Lm5vcihbeyBjb2xvcjogJ2dyZWVuJyB9LCB7IHN0YXR1czogJ29rJyB9XSlcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubm9yID0gZnVuY3Rpb24gbm9yKGFycmF5KSB7XG4gIGNvbnN0IG5vciA9IHRoaXMuX2NvbmRpdGlvbnMuJG5vciB8fCAodGhpcy5fY29uZGl0aW9ucy4kbm9yID0gW10pO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSBhcnJheSA9IFthcnJheV07XG4gIG5vci5wdXNoLmFwcGx5KG5vciwgYXJyYXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFyZ3VtZW50cyBmb3IgYSBgJGFuZGAgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuYW5kKFt7IGNvbG9yOiAnZ3JlZW4nIH0sIHsgc3RhdHVzOiAnb2snIH1dKVxuICpcbiAqIEBzZWUgJGFuZCBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FuZC9cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IGFycmF5IG9mIGNvbmRpdGlvbnNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQoYXJyYXkpIHtcbiAgY29uc3QgYW5kID0gdGhpcy5fY29uZGl0aW9ucy4kYW5kIHx8ICh0aGlzLl9jb25kaXRpb25zLiRhbmQgPSBbXSk7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIGFycmF5ID0gW2FycmF5XTtcbiAgYW5kLnB1c2guYXBwbHkoYW5kLCBhcnJheSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkZ3QgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBUaGluZy5maW5kKCkud2hlcmUoJ2FnZScpLmd0KDIxKVxuICpcbiAqICAgICAvLyBvclxuICogICAgIFRoaW5nLmZpbmQoKS5ndCgnYWdlJywgMjEpXG4gKlxuICogQG1ldGhvZCBndFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGd0ZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGd0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGx0IHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbHRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRsdGUgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRuZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIG5lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gJGluIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgaW5cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiAkbmluIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbmluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gJGFsbCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGFsbFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJHNpemUgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBzaXplXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkcmVnZXggcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCByZWdleFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRtYXhEaXN0YW5jZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIG1heERpc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyohXG4gKiBndCwgZ3RlLCBsdCwgbHRlLCBuZSwgaW4sIG5pbiwgYWxsLCByZWdleCwgc2l6ZSwgbWF4RGlzdGFuY2VcbiAqXG4gKiAgICAgVGhpbmcud2hlcmUoJ3R5cGUnKS5uaW4oYXJyYXkpXG4gKi9cblxuJ2d0IGd0ZSBsdCBsdGUgbmUgaW4gbmluIGFsbCByZWdleCBzaXplIG1heERpc3RhbmNlIG1pbkRpc3RhbmNlJy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oJGNvbmRpdGlvbmFsKSB7XG4gIFF1ZXJ5LnByb3RvdHlwZVskY29uZGl0aW9uYWxdID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHBhdGgsIHZhbDtcblxuICAgIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9lbnN1cmVQYXRoKCRjb25kaXRpb25hbCk7XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gICAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICAgICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPT09IG51bGwgfHwgdHlwZW9mIHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPT09ICdvYmplY3QnID9cbiAgICAgIHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gOlxuICAgICAgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gICAgY29uZHNbJyQnICsgJGNvbmRpdGlvbmFsXSA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbW9kYCBjb25kaXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24oKSB7XG4gIGxldCB2YWwsIHBhdGg7XG5cbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdtb2QnKTtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiAhQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMV0pKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbW9kJyk7XG4gICAgdmFsID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgfSBlbHNlIGlmICgzID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdmFsID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kcy4kbW9kID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkZXhpc3RzYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHsgbmFtZTogeyAkZXhpc3RzOiB0cnVlIH19XG4gKiAgICAgVGhpbmcud2hlcmUoJ25hbWUnKS5leGlzdHMoKVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKHRydWUpXG4gKiAgICAgVGhpbmcuZmluZCgpLmV4aXN0cygnbmFtZScpXG4gKlxuICogICAgIC8vIHsgbmFtZTogeyAkZXhpc3RzOiBmYWxzZSB9fVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKGZhbHNlKTtcbiAqICAgICBUaGluZy5maW5kKCkuZXhpc3RzKCduYW1lJywgZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHBhdGgsIHZhbDtcblxuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2V4aXN0cycpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiBhcmd1bWVudHNbMF0pIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2V4aXN0cycpO1xuICAgICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICB2YWwgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzLiRleGlzdHMgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gYCRlbGVtTWF0Y2hgIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZWxlbU1hdGNoKCdjb21tZW50JywgeyBhdXRob3I6ICdhdXRvYm90Jywgdm90ZXM6IHskZ3RlOiA1fX0pXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50JykuZWxlbU1hdGNoKHsgYXV0aG9yOiAnYXV0b2JvdCcsIHZvdGVzOiB7JGd0ZTogNX19KVxuICpcbiAqICAgICBxdWVyeS5lbGVtTWF0Y2goJ2NvbW1lbnQnLCBmdW5jdGlvbiAoZWxlbSkge1xuICogICAgICAgZWxlbS53aGVyZSgnYXV0aG9yJykuZXF1YWxzKCdhdXRvYm90Jyk7XG4gKiAgICAgICBlbGVtLndoZXJlKCd2b3RlcycpLmd0ZSg1KTtcbiAqICAgICB9KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudCcpLmVsZW1NYXRjaChmdW5jdGlvbiAoZWxlbSkge1xuICogICAgICAgZWxlbS53aGVyZSh7IGF1dGhvcjogJ2F1dG9ib3QnIH0pO1xuICogICAgICAgZWxlbS53aGVyZSgndm90ZXMnKS5ndGUoNSk7XG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBjcml0ZXJpYVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmVsZW1NYXRjaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAobnVsbCA9PSBhcmd1bWVudHNbMF0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuXG4gIGxldCBmbiwgcGF0aCwgY3JpdGVyaWE7XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmd1bWVudHNbMF0pIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdlbGVtTWF0Y2gnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICBmbiA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdChhcmd1bWVudHNbMF0pKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnZWxlbU1hdGNoJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgY3JpdGVyaWEgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1sxXSkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgZm4gPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzFdICYmIHV0aWxzLmlzT2JqZWN0KGFyZ3VtZW50c1sxXSkpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGNyaXRlcmlhID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmIChmbikge1xuICAgIGNyaXRlcmlhID0gbmV3IFF1ZXJ5O1xuICAgIGZuKGNyaXRlcmlhKTtcbiAgICBjcml0ZXJpYSA9IGNyaXRlcmlhLl9jb25kaXRpb25zO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kcy4kZWxlbU1hdGNoID0gY3JpdGVyaWE7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gU3BhdGlhbCBxdWVyaWVzXG5cbi8qKlxuICogU3VnYXIgZm9yIGdlby1zcGF0aWFsIHF1ZXJpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aXRoaW4oKS5ib3goKVxuICogICAgIHF1ZXJ5LndpdGhpbigpLmNpcmNsZSgpXG4gKiAgICAgcXVlcnkud2l0aGluKCkuZ2VvbWV0cnkoKVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgY2VudGVyOiBbNTAsNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUsIHNwaGVyaWNhbDogdHJ1ZSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgYm94OiBbWzQwLjczLCAtNzMuOV0sIFs0MC43LCAtNzMuOTg4XV0gfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IHBvbHlnb246IFtbXSxbXSxbXSxbXV0gfSk7XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oW10sIFtdLCBbXSkgLy8gcG9seWdvblxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oW10sIFtdKSAvLyBib3hcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgdHlwZTogJ0xpbmVTdHJpbmcnLCBjb29yZGluYXRlczogWy4uLl0gfSk7IC8vIGdlb21ldHJ5XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIE11c3QgYmUgdXNlZCBhZnRlciBgd2hlcmUoKWAuXG4gKlxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud2l0aGluID0gZnVuY3Rpb24gd2l0aGluKCkge1xuICAvLyBvcGluaW9uYXRlZCwgbXVzdCBiZSB1c2VkIGFmdGVyIHdoZXJlXG4gIHRoaXMuX2Vuc3VyZVBhdGgoJ3dpdGhpbicpO1xuICB0aGlzLl9nZW9Db21wYXJpc29uID0gJHdpdGhpbkNtZDtcblxuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSBlbHNlIGlmICgyIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnBvbHlnb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGNvbnN0IGFyZWEgPSBhcmd1bWVudHNbMF07XG5cbiAgaWYgKCFhcmVhKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcblxuICBpZiAoYXJlYS5jZW50ZXIpXG4gICAgcmV0dXJuIHRoaXMuY2lyY2xlKGFyZWEpO1xuXG4gIGlmIChhcmVhLmJveClcbiAgICByZXR1cm4gdGhpcy5ib3guYXBwbHkodGhpcywgYXJlYS5ib3gpO1xuXG4gIGlmIChhcmVhLnBvbHlnb24pXG4gICAgcmV0dXJuIHRoaXMucG9seWdvbi5hcHBseSh0aGlzLCBhcmVhLnBvbHlnb24pO1xuXG4gIGlmIChhcmVhLnR5cGUgJiYgYXJlYS5jb29yZGluYXRlcylcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeShhcmVhKTtcblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRib3ggY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgbG93ZXJMZWZ0ID0gWzQwLjczMDgzLCAtNzMuOTk3NTZdXG4gKiAgICAgdmFyIHVwcGVyUmlnaHQ9IFs0MC43NDE0MDQsICAtNzMuOTg4MTM1XVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuYm94KGxvd2VyTGVmdCwgdXBwZXJSaWdodClcbiAqICAgICBxdWVyeS5ib3goJ2xvYycsIGxvd2VyTGVmdCwgdXBwZXJSaWdodCApXG4gKlxuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAc2VlIFF1ZXJ5I3dpdGhpbiAjcXVlcnlfUXVlcnktd2l0aGluXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmJveCA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcGF0aCwgYm94O1xuXG4gIGlmICgzID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgLy8gYm94KCdsb2MnLCBbXSwgW10pXG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBib3ggPSBbYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl1dO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAvLyBib3goW10sIFtdKVxuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2JveCcpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIGJveCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kc1t0aGlzLl9nZW9Db21wYXJpc29uIHx8ICR3aXRoaW5DbWRdID0geyAkYm94OiBib3ggfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRwb2x5Z29uIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLnBvbHlnb24oWzEwLDIwXSwgWzEzLCAyNV0sIFs3LDE1XSlcbiAqICAgICBxdWVyeS5wb2x5Z29uKCdsb2MnLCBbMTAsMjBdLCBbMTMsIDI1XSwgWzcsMTVdKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbcGF0aF1cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBbdmFsXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucG9seWdvbiA9IGZ1bmN0aW9uKCkge1xuICBsZXQgdmFsLCBwYXRoO1xuXG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgYXJndW1lbnRzWzBdKSB7XG4gICAgLy8gcG9seWdvbignbG9jJywgW10sW10sW10pXG4gICAgdmFsID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgIHBhdGggPSB2YWwuc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwb2x5Z29uKFtdLFtdLFtdKVxuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ3BvbHlnb24nKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzW3RoaXMuX2dlb0NvbXBhcmlzb24gfHwgJHdpdGhpbkNtZF0gPSB7ICRwb2x5Z29uOiB2YWwgfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRjZW50ZXIgb3IgJGNlbnRlclNwaGVyZSBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgYXJlYSA9IHsgY2VudGVyOiBbNTAsIDUwXSwgcmFkaXVzOiAxMCwgdW5pcXVlOiB0cnVlIH1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuY2lyY2xlKGFyZWEpXG4gKiAgICAgcXVlcnkuY2VudGVyKCdsb2MnLCBhcmVhKTtcbiAqXG4gKiAgICAgLy8gZm9yIHNwaGVyaWNhbCBjYWxjdWxhdGlvbnNcbiAqICAgICB2YXIgYXJlYSA9IHsgY2VudGVyOiBbNTAsIDUwXSwgcmFkaXVzOiAxMCwgdW5pcXVlOiB0cnVlLCBzcGhlcmljYWw6IHRydWUgfVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5jaXJjbGUoYXJlYSlcbiAqICAgICBxdWVyeS5jZW50ZXIoJ2xvYycsIGFyZWEpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmVhXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jaXJjbGUgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHBhdGgsIHZhbDtcblxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2NpcmNsZScpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKCEoJ3JhZGl1cycgaW4gdmFsICYmIHZhbC5jZW50ZXIpKVxuICAgIHRocm93IG5ldyBFcnJvcignY2VudGVyIGFuZCByYWRpdXMgYXJlIHJlcXVpcmVkJyk7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuXG4gIGNvbnN0IHR5cGUgPSB2YWwuc3BoZXJpY2FsXG4gICAgPyAnJGNlbnRlclNwaGVyZSdcbiAgICA6ICckY2VudGVyJztcblxuICBjb25zdCB3S2V5ID0gdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fCAkd2l0aGluQ21kO1xuICBjb25kc1t3S2V5XSA9IHt9O1xuICBjb25kc1t3S2V5XVt0eXBlXSA9IFt2YWwuY2VudGVyLCB2YWwucmFkaXVzXTtcblxuICBpZiAoJ3VuaXF1ZScgaW4gdmFsKVxuICAgIGNvbmRzW3dLZXldLiR1bmlxdWVEb2NzID0gISF2YWwudW5pcXVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJG5lYXJgIG9yIGAkbmVhclNwaGVyZWAgY29uZGl0aW9uXG4gKlxuICogVGhlc2Ugb3BlcmF0b3JzIHJldHVybiBkb2N1bWVudHMgc29ydGVkIGJ5IGRpc3RhbmNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyKHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUgfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSwgc3BoZXJpY2FsOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5Lm5lYXIoJ2xvYycsIHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUgfSk7XG4gKiAgICAgcXVlcnkubmVhcih7IGNlbnRlcjogeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogWy4uXSB9fSlcbiAqICAgICBxdWVyeS5uZWFyKCkuZ2VvbWV0cnkoeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogWy4uXSB9KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm5lYXIgPSBmdW5jdGlvbiBuZWFyKCkge1xuICBsZXQgcGF0aCwgdmFsO1xuXG4gIHRoaXMuX2dlb0NvbXBhcmlzb24gPSAnJG5lYXInO1xuXG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ25lYXInKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICghdmFsLmNlbnRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignY2VudGVyIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG5cbiAgY29uc3QgdHlwZSA9IHZhbC5zcGhlcmljYWxcbiAgICA/ICckbmVhclNwaGVyZSdcbiAgICA6ICckbmVhcic7XG5cbiAgLy8gY2VudGVyIGNvdWxkIGJlIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gQXJyYXlcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsLmNlbnRlcikpIHtcbiAgICBjb25kc1t0eXBlXSA9IHZhbC5jZW50ZXI7XG5cbiAgICBjb25zdCByYWRpdXMgPSAnbWF4RGlzdGFuY2UnIGluIHZhbFxuICAgICAgPyB2YWwubWF4RGlzdGFuY2VcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChudWxsICE9IHJhZGl1cykge1xuICAgICAgY29uZHMuJG1heERpc3RhbmNlID0gcmFkaXVzO1xuICAgIH1cbiAgICBpZiAobnVsbCAhPSB2YWwubWluRGlzdGFuY2UpIHtcbiAgICAgIGNvbmRzLiRtaW5EaXN0YW5jZSA9IHZhbC5taW5EaXN0YW5jZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gR2VvSlNPTj9cbiAgICBpZiAodmFsLmNlbnRlci50eXBlICE9ICdQb2ludCcgfHwgIUFycmF5LmlzQXJyYXkodmFsLmNlbnRlci5jb29yZGluYXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnSW52YWxpZCBHZW9KU09OIHNwZWNpZmllZCBmb3IgJXMnLCB0eXBlKSk7XG4gICAgfVxuICAgIGNvbmRzW3R5cGVdID0geyAkZ2VvbWV0cnk6IHZhbC5jZW50ZXIgfTtcblxuICAgIC8vIE1vbmdvREIgMi42IGluc2lzdHMgb24gbWF4RGlzdGFuY2UgYmVpbmcgaW4gJG5lYXIgLyAkbmVhclNwaGVyZVxuICAgIGlmICgnbWF4RGlzdGFuY2UnIGluIHZhbCkge1xuICAgICAgY29uZHNbdHlwZV1bJyRtYXhEaXN0YW5jZSddID0gdmFsLm1heERpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAoJ21pbkRpc3RhbmNlJyBpbiB2YWwpIHtcbiAgICAgIGNvbmRzW3R5cGVdWyckbWluRGlzdGFuY2UnXSA9IHZhbC5taW5EaXN0YW5jZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYW4gaW50ZXJzZWN0cyBxdWVyeSBmb3IgYGdlb21ldHJ5KClgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ3BhdGgnKS5pbnRlcnNlY3RzKCkuZ2VvbWV0cnkoe1xuICogICAgICAgICB0eXBlOiAnTGluZVN0cmluZydcbiAqICAgICAgICwgY29vcmRpbmF0ZXM6IFtbMTgwLjAsIDExLjBdLCBbMTgwLCA5LjBdXVxuICogICAgIH0pXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdwYXRoJykuaW50ZXJzZWN0cyh7XG4gKiAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJ1xuICogICAgICAgLCBjb29yZGluYXRlczogW1sxODAuMCwgMTEuMF0sIFsxODAsIDkuMF1dXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cygpIHtcbiAgLy8gb3BpbmlvbmF0ZWQsIG11c3QgYmUgdXNlZCBhZnRlciB3aGVyZVxuICB0aGlzLl9lbnN1cmVQYXRoKCdpbnRlcnNlY3RzJyk7XG5cbiAgdGhpcy5fZ2VvQ29tcGFyaXNvbiA9ICckZ2VvSW50ZXJzZWN0cyc7XG5cbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IGFyZWEgPSBhcmd1bWVudHNbMF07XG5cbiAgaWYgKG51bGwgIT0gYXJlYSAmJiBhcmVhLnR5cGUgJiYgYXJlYS5jb29yZGluYXRlcylcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeShhcmVhKTtcblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkZ2VvbWV0cnlgIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIHBvbHlBID0gW1tbIDEwLCAyMCBdLCBbIDEwLCA0MCBdLCBbIDMwLCA0MCBdLCBbIDMwLCAyMCBdXV1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuZ2VvbWV0cnkoeyB0eXBlOiAnUG9seWdvbicsIGNvb3JkaW5hdGVzOiBwb2x5QSB9KVxuICpcbiAqICAgICAvLyBvclxuICogICAgIHZhciBwb2x5QiA9IFtbIDAsIDAgXSwgWyAxLCAxIF1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ0xpbmVTdHJpbmcnLCBjb29yZGluYXRlczogcG9seUIgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICB2YXIgcG9seUMgPSBbIDAsIDAgXVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBwb2x5QyB9KVxuICpcbiAqICAgICAvLyBvclxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5pbnRlcnNlY3RzKCkuZ2VvbWV0cnkoeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogcG9seUMgfSlcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogYGdlb21ldHJ5KClgICoqbXVzdCoqIGNvbWUgYWZ0ZXIgZWl0aGVyIGBpbnRlcnNlY3RzKClgIG9yIGB3aXRoaW4oKWAuXG4gKlxuICogVGhlIGBvYmplY3RgIGFyZ3VtZW50IG11c3QgY29udGFpbiBgdHlwZWAgYW5kIGBjb29yZGluYXRlc2AgcHJvcGVydGllcy5cbiAqIC0gdHlwZSB7U3RyaW5nfVxuICogLSBjb29yZGluYXRlcyB7QXJyYXl9XG4gKlxuICogVGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgTXVzdCBjb250YWluIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIGlzIGEgU3RyaW5nIGFuZCBhIGBjb29yZGluYXRlc2AgcHJvcGVydHkgd2hpY2ggaXMgYW4gQXJyYXkuIFNlZSB0aGUgZXhhbXBsZXMuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVsZWFzZS1ub3Rlcy8yLjQvI25ldy1nZW9zcGF0aWFsLWluZGV4ZXMtd2l0aC1nZW9qc29uLWFuZC1pbXByb3ZlZC1zcGhlcmljYWwtZ2VvbWV0cnlcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQHNlZSAkZ2VvbWV0cnkgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9nZW9tZXRyeS9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdlb21ldHJ5ID0gZnVuY3Rpb24gZ2VvbWV0cnkoKSB7XG4gIGlmICghKCckd2l0aGluJyA9PSB0aGlzLl9nZW9Db21wYXJpc29uIHx8XG4gICAgICAgICckZ2VvV2l0aGluJyA9PSB0aGlzLl9nZW9Db21wYXJpc29uIHx8XG4gICAgICAgICckbmVhcicgPT0gdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fFxuICAgICAgICAnJGdlb0ludGVyc2VjdHMnID09IHRoaXMuX2dlb0NvbXBhcmlzb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZW9tZXRyeSgpIG11c3QgY29tZSBhZnRlciBgd2l0aGluKClgLCBgaW50ZXJzZWN0cygpYCwgb3IgYG5lYXIoKScpO1xuICB9XG5cbiAgbGV0IHZhbCwgcGF0aDtcblxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2dlb21ldHJ5Jyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICghKHZhbC50eXBlICYmIEFycmF5LmlzQXJyYXkodmFsLmNvb3JkaW5hdGVzKSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzW3RoaXMuX2dlb0NvbXBhcmlzb25dID0geyAkZ2VvbWV0cnk6IHZhbCB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW5kIHNwYXRpYWxcblxuLyoqXG4gKiBTcGVjaWZpZXMgd2hpY2ggZG9jdW1lbnQgZmllbGRzIHRvIGluY2x1ZGUgb3IgZXhjbHVkZVxuICpcbiAqICMjIyMgU3RyaW5nIHN5bnRheFxuICpcbiAqIFdoZW4gcGFzc2luZyBhIHN0cmluZywgcHJlZml4aW5nIGEgcGF0aCB3aXRoIGAtYCB3aWxsIGZsYWcgdGhhdCBwYXRoIGFzIGV4Y2x1ZGVkLiBXaGVuIGEgcGF0aCBkb2VzIG5vdCBoYXZlIHRoZSBgLWAgcHJlZml4LCBpdCBpcyBpbmNsdWRlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluY2x1ZGUgYSBhbmQgYiwgZXhjbHVkZSBjXG4gKiAgICAgcXVlcnkuc2VsZWN0KCdhIGIgLWMnKTtcbiAqXG4gKiAgICAgLy8gb3IgeW91IG1heSB1c2Ugb2JqZWN0IG5vdGF0aW9uLCB1c2VmdWwgd2hlblxuICogICAgIC8vIHlvdSBoYXZlIGtleXMgYWxyZWFkeSBwcmVmaXhlZCB3aXRoIGEgXCItXCJcbiAqICAgICBxdWVyeS5zZWxlY3Qoe2E6IDEsIGI6IDEsIGM6IDB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0KCkge1xuICBsZXQgYXJnID0gYXJndW1lbnRzWzBdO1xuICBpZiAoIWFyZykgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0OiBzZWxlY3Qgb25seSB0YWtlcyAxIGFyZ3VtZW50Jyk7XG4gIH1cblxuICB0aGlzLl92YWxpZGF0ZSgnc2VsZWN0Jyk7XG5cbiAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzIHx8ICh0aGlzLl9maWVsZHMgPSB7fSk7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuICBsZXQgaSwgbGVuO1xuXG4gIGlmICgoJ3N0cmluZycgPT0gdHlwZSB8fCB1dGlscy5pc0FyZ3VtZW50c09iamVjdChhcmcpKSAmJlxuICAgICdudW1iZXInID09IHR5cGVvZiBhcmcubGVuZ3RoIHx8IEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlKVxuICAgICAgYXJnID0gYXJnLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhcmcubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGxldCBmaWVsZCA9IGFyZ1tpXTtcbiAgICAgIGlmICghZmllbGQpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgaW5jbHVkZSA9ICctJyA9PSBmaWVsZFswXSA/IDAgOiAxO1xuICAgICAgaWYgKGluY2x1ZGUgPT09IDApIGZpZWxkID0gZmllbGQuc3Vic3RyaW5nKDEpO1xuICAgICAgZmllbGRzW2ZpZWxkXSA9IGluY2x1ZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodXRpbHMuaXNPYmplY3QoYXJnKSkge1xuICAgIGNvbnN0IGtleXMgPSB1dGlscy5rZXlzKGFyZyk7XG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZpZWxkc1trZXlzW2ldXSA9IGFyZ1trZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNlbGVjdCgpIGFyZ3VtZW50LiBNdXN0IGJlIHN0cmluZyBvciBvYmplY3QuJyk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRzbGljZSBjb25kaXRpb24gZm9yIGEgYHBhdGhgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCA1KVxuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIC01KVxuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIFsxMCwgNV0pXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnRzJykuc2xpY2UoNSlcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudHMnKS5zbGljZShbLTEwLCA1XSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsIG51bWJlci9yYW5nZSBvZiBlbGVtZW50cyB0byBzbGljZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9SZXRyaWV2aW5nK2ErU3Vic2V0K29mK0ZpZWxkcyNSZXRyaWV2aW5nYVN1YnNldG9mRmllbGRzLVJldHJpZXZpbmdhU3VicmFuZ2VvZkFycmF5RWxlbWVudHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuX3ZhbGlkYXRlKCdzbGljZScpO1xuXG4gIGxldCBwYXRoLCB2YWw7XG5cbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCBhcmcgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICAgICAgdGhpcy5zbGljZShrZXlzW2ldLCBhcmdba2V5c1tpXV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ3NsaWNlJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBhcmd1bWVudHNbMF0pIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ3NsaWNlJyk7XG4gICAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIHZhbCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2UgaWYgKDMgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gIH1cblxuICBjb25zdCBteUZpZWxkcyA9IHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICBteUZpZWxkc1twYXRoXSA9IHsgJHNsaWNlOiB2YWwgfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNvcnQgb3JkZXJcbiAqXG4gKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkLCB2YWx1ZXMgYWxsb3dlZCBhcmUgJ2FzYycsICdkZXNjJywgJ2FzY2VuZGluZycsICdkZXNjZW5kaW5nJywgMSwgYW5kIC0xLlxuICpcbiAqIElmIGEgc3RyaW5nIGlzIHBhc3NlZCwgaXQgbXVzdCBiZSBhIHNwYWNlIGRlbGltaXRlZCBsaXN0IG9mIHBhdGggbmFtZXMuIFRoZSBzb3J0IG9yZGVyIG9mIGVhY2ggcGF0aCBpcyBhc2NlbmRpbmcgdW5sZXNzIHRoZSBwYXRoIG5hbWUgaXMgcHJlZml4ZWQgd2l0aCBgLWAgd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGRlc2NlbmRpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB0aGVzZSBhcmUgZXF1aXZhbGVudFxuICogICAgIHF1ZXJ5LnNvcnQoeyBmaWVsZDogJ2FzYycsIHRlc3Q6IC0xIH0pO1xuICogICAgIHF1ZXJ5LnNvcnQoJ2ZpZWxkIC10ZXN0Jyk7XG4gKiAgICAgcXVlcnkuc29ydChbWydmaWVsZCcsIDFdLCBbJ3Rlc3QnLCAtMV1dKTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogIC0gVGhlIGFycmF5IHN5bnRheCBgLnNvcnQoW1snZmllbGQnLCAxXSwgWyd0ZXN0JywgLTFdXSlgIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBbbW9uZ29kYiBkcml2ZXIgPj0gMi4wLjQ2XShodHRwczovL2dpdGh1Yi5jb20vbW9uZ29kYi9ub2RlLW1vbmdvZGItbmF0aXZlL2Jsb2IvMi4xL0hJU1RPUlkubWQjMjA0Ni0yMDE1LTEwLTE1KS5cbiAqICAtIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEFycmF5fSBhcmdcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmICghYXJnKSByZXR1cm4gdGhpcztcbiAgbGV0IGksIGxlbiwgZmllbGQ7XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NvcnQnKTtcblxuICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZztcblxuICAvLyAuc29ydChbWydmaWVsZCcsIDFdLCBbJ3Rlc3QnLCAtMV1dKVxuICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnW2ldKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LCBtdXN0IGJlIGFycmF5IG9mIGFycmF5cycpO1xuICAgICAgfVxuICAgICAgX3B1c2hBcnIodGhpcy5vcHRpb25zLCBhcmdbaV1bMF0sIGFyZ1tpXVsxXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gLnNvcnQoJ2ZpZWxkIC10ZXN0JylcbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgJ3N0cmluZycgPT0gdHlwZSkge1xuICAgIGFyZyA9IGFyZy5zcGxpdCgvXFxzKy8pO1xuICAgIGxlbiA9IGFyZy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBmaWVsZCA9IGFyZ1tpXTtcbiAgICAgIGlmICghZmllbGQpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYXNjZW5kID0gJy0nID09IGZpZWxkWzBdID8gLTEgOiAxO1xuICAgICAgaWYgKGFzY2VuZCA9PT0gLTEpIGZpZWxkID0gZmllbGQuc3Vic3RyaW5nKDEpO1xuICAgICAgcHVzaCh0aGlzLm9wdGlvbnMsIGZpZWxkLCBhc2NlbmQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gLnNvcnQoeyBmaWVsZDogMSwgdGVzdDogLTEgfSlcbiAgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZykpIHtcbiAgICBjb25zdCBrZXlzID0gdXRpbHMua2V5cyhhcmcpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBmaWVsZCA9IGtleXNbaV07XG4gICAgICBwdXNoKHRoaXMub3B0aW9ucywgZmllbGQsIGFyZ1tmaWVsZF0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmIGFyZyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIF9wdXNoTWFwKHRoaXMub3B0aW9ucywgYXJnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQoKSBhcmd1bWVudC4gTXVzdCBiZSBhIHN0cmluZywgb2JqZWN0LCBvciBhcnJheS4nKTtcbn07XG5cbi8qIVxuICogQGlnbm9yZVxuICovXG5cbmNvbnN0IF92YWxpZFNvcnRWYWx1ZSA9IHtcbiAgMTogMSxcbiAgJy0xJzogLTEsXG4gIGFzYzogMSxcbiAgYXNjZW5kaW5nOiAxLFxuICBkZXNjOiAtMSxcbiAgZGVzY2VuZGluZzogLTFcbn07XG5cbmZ1bmN0aW9uIHB1c2gob3B0cywgZmllbGQsIHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHMuc29ydCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5cXCd0IG1peCBzb3J0IHN5bnRheGVzLiBVc2UgZWl0aGVyIGFycmF5IG9yIG9iamVjdDonICtcbiAgICAgICdcXG4tIGAuc29ydChbW1xcJ2ZpZWxkXFwnLCAxXSwgW1xcJ3Rlc3RcXCcsIC0xXV0pYCcgK1xuICAgICAgJ1xcbi0gYC5zb3J0KHsgZmllbGQ6IDEsIHRlc3Q6IC0xIH0pYCcpO1xuICB9XG5cbiAgbGV0IHM7XG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS4kbWV0YSkge1xuICAgIHMgPSBvcHRzLnNvcnQgfHwgKG9wdHMuc29ydCA9IHt9KTtcbiAgICBzW2ZpZWxkXSA9IHsgJG1ldGE6IHZhbHVlLiRtZXRhIH07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcyA9IG9wdHMuc29ydCB8fCAob3B0cy5zb3J0ID0ge30pO1xuICBsZXQgdmFsID0gU3RyaW5nKHZhbHVlIHx8IDEpLnRvTG93ZXJDYXNlKCk7XG4gIHZhbCA9IF92YWxpZFNvcnRWYWx1ZVt2YWxdO1xuICBpZiAoIXZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0IHZhbHVlOiB7ICcgKyBmaWVsZCArICc6ICcgKyB2YWx1ZSArICcgfScpO1xuXG4gIHNbZmllbGRdID0gdmFsO1xufVxuXG5mdW5jdGlvbiBfcHVzaEFycihvcHRzLCBmaWVsZCwgdmFsdWUpIHtcbiAgb3B0cy5zb3J0ID0gb3B0cy5zb3J0IHx8IFtdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkob3B0cy5zb3J0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhblxcJ3QgbWl4IHNvcnQgc3ludGF4ZXMuIFVzZSBlaXRoZXIgYXJyYXkgb3Igb2JqZWN0OicgK1xuICAgICAgJ1xcbi0gYC5zb3J0KFtbXFwnZmllbGRcXCcsIDFdLCBbXFwndGVzdFxcJywgLTFdXSlgJyArXG4gICAgICAnXFxuLSBgLnNvcnQoeyBmaWVsZDogMSwgdGVzdDogLTEgfSlgJyk7XG4gIH1cblxuICBsZXQgdmFsID0gU3RyaW5nKHZhbHVlIHx8IDEpLnRvTG93ZXJDYXNlKCk7XG4gIHZhbCA9IF92YWxpZFNvcnRWYWx1ZVt2YWxdO1xuICBpZiAoIXZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0IHZhbHVlOiBbICcgKyBmaWVsZCArICcsICcgKyB2YWx1ZSArICcgXScpO1xuXG4gIG9wdHMuc29ydC5wdXNoKFtmaWVsZCwgdmFsXSk7XG59XG5cbmZ1bmN0aW9uIF9wdXNoTWFwKG9wdHMsIG1hcCkge1xuICBvcHRzLnNvcnQgPSBvcHRzLnNvcnQgfHwgbmV3IE1hcCgpO1xuICBpZiAoIShvcHRzLnNvcnQgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuXFwndCBtaXggc29ydCBzeW50YXhlcy4gVXNlIGVpdGhlciBhcnJheSBvciAnICtcbiAgICAgICdvYmplY3Qgb3IgbWFwIGNvbnNpc3RlbnRseScpO1xuICB9XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICBsZXQgdmFsID0gU3RyaW5nKHZhbHVlIHx8IDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gX3ZhbGlkU29ydFZhbHVlW3ZhbF07XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCB2YWx1ZTogPCAnICsga2V5ICsgJzogJyArIHZhbHVlICsgJyA+Jyk7XG5cbiAgICBvcHRzLnNvcnQuc2V0KGtleSwgdmFsKTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGxpbWl0IG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmxpbWl0KDIwKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgbGltaXRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QmxpbWl0JTI4JTI5JTdEJTdEXG4gKiBAYXBpIHB1YmxpY1xuICovXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgc2tpcCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5za2lwKDEwMCkubGltaXQoMjApXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBza2lwXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0Jza2lwJTI4JTI5JTdEJTdEXG4gKiBAYXBpIHB1YmxpY1xuICovXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYmF0Y2hTaXplIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmJhdGNoU2l6ZSgxMDApXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBiYXRjaFNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QmJhdGNoU2l6ZSUyOCUyOSU3RCU3RFxuICogQGFwaSBwdWJsaWNcbiAqL1xuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGBjb21tZW50YCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5jb21tZW50KCdsb2dpbiBxdWVyeScpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBjb21tZW50XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lMjRjb21tZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qIVxuICogbGltaXQsIHNraXAsIGJhdGNoU2l6ZSwgY29tbWVudFxuICpcbiAqIFNldHMgdGhlc2UgYXNzb2NpYXRlZCBvcHRpb25zLlxuICpcbiAqICAgICBxdWVyeS5jb21tZW50KCdmZWVkIHF1ZXJ5Jyk7XG4gKi9cblxuWydsaW1pdCcsICdza2lwJywgJ2JhdGNoU2l6ZScsICdjb21tZW50J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgUXVlcnkucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih2KSB7XG4gICAgdGhpcy5fdmFsaWRhdGUobWV0aG9kKTtcbiAgICB0aGlzLm9wdGlvbnNbbWV0aG9kXSA9IHY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIG1heFRpbWVNUyBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5tYXhUaW1lKDEwMClcbiAqICAgICBxdWVyeS5tYXhUaW1lTVMoMTAwKVxuICpcbiAqIEBtZXRob2QgbWF4VGltZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21ldGEvbWF4VGltZU1TLyNvcC5fU19tYXhUaW1lTVNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1heFRpbWUgPSBRdWVyeS5wcm90b3R5cGUubWF4VGltZU1TID0gZnVuY3Rpb24obXMpIHtcbiAgdGhpcy5fdmFsaWRhdGUoJ21heFRpbWUnKTtcbiAgdGhpcy5vcHRpb25zLm1heFRpbWVNUyA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBxdWVyeSBoaW50cy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmhpbnQoeyBpbmRleEE6IDEsIGluZGV4QjogLTF9KTtcbiAqICAgICBxdWVyeS5oaW50KCdpbmRleEFfMV9pbmRleEJfMScpO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gdmFsIGEgaGludCBvYmplY3Qgb3IgdGhlIGluZGV4IG5hbWVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTI0aGludFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaGludCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ2hpbnQnKTtcblxuICBjb25zdCBhcmcgPSBhcmd1bWVudHNbMF07XG4gIGlmICh1dGlscy5pc09iamVjdChhcmcpKSB7XG4gICAgY29uc3QgaGludCA9IHRoaXMub3B0aW9ucy5oaW50IHx8ICh0aGlzLm9wdGlvbnMuaGludCA9IHt9KTtcblxuICAgIC8vIG11c3Qga2VlcCBvYmplY3Qga2V5cyBpbiBvcmRlciBzbyBkb24ndCB1c2UgT2JqZWN0LmtleXMoKVxuICAgIGZvciAoY29uc3QgayBpbiBhcmcpIHtcbiAgICAgIGhpbnRba10gPSBhcmdba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5vcHRpb25zLmhpbnQgPSBhcmc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhpbnQuICcgKyBhcmcpO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyBhY2tub3dsZWRnZW1lbnQgdGhhdCB0aGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBwZXJzaXN0ZWQgdG8gTW9uZ29EQidzXG4gKiBvbi1kaXNrIGpvdXJuYWwuXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIGBqYCB2YWx1ZSBpZiBpdCBpcyBzcGVjaWZpZWQgaW4gd3JpdGVDb25jZXJuIG9wdGlvbnNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1xdWVyeSgpLncoMikuaih0cnVlKS53dGltZW91dCgyMDAwKTtcbiAqXG4gKiBAbWV0aG9kIGpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI2otb3B0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaiA9IGZ1bmN0aW9uIGoodmFsKSB7XG4gIHRoaXMub3B0aW9ucy5qID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2xhdmVPayBvcHRpb24uIF9EZXByZWNhdGVkXyBpbiBNb25nb0RCIDIuMiBpbiBmYXZvciBvZiByZWFkIHByZWZlcmVuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2xhdmVPaygpIC8vIHRydWVcbiAqICAgICBxdWVyeS5zbGF2ZU9rKHRydWUpXG4gKiAgICAgcXVlcnkuc2xhdmVPayhmYWxzZSlcbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgcmVhZCgpIHByZWZlcmVuY2VzIGluc3RlYWQgaWYgb24gbW9uZ29kYiA+PSAyLjJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdiBkZWZhdWx0cyB0byB0cnVlXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlXG4gKiBAc2VlIHJlYWQoKVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNsYXZlT2sgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMub3B0aW9ucy5zbGF2ZU9rID0gYXJndW1lbnRzLmxlbmd0aCA/ICEhdiA6IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWFkUHJlZmVyZW5jZSBvcHRpb24gZm9yIHRoZSBxdWVyeS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3ByaW1hcnknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3AnKSAgLy8gc2FtZSBhcyBwcmltYXJ5XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3ByaW1hcnlQcmVmZXJyZWQnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3BwJykgLy8gc2FtZSBhcyBwcmltYXJ5UHJlZmVycmVkXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3NlY29uZGFyeScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncycpICAvLyBzYW1lIGFzIHNlY29uZGFyeVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzZWNvbmRhcnlQcmVmZXJyZWQnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3NwJykgLy8gc2FtZSBhcyBzZWNvbmRhcnlQcmVmZXJyZWRcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnbmVhcmVzdCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnbicpICAvLyBzYW1lIGFzIG5lYXJlc3RcbiAqXG4gKiAgICAgLy8geW91IGNhbiBhbHNvIHVzZSBtb25nb2RiLlJlYWRQcmVmZXJlbmNlIGNsYXNzIHRvIGFsc28gc3BlY2lmeSB0YWdzXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZChtb25nb2RiLlJlYWRQcmVmZXJlbmNlKCdzZWNvbmRhcnknLCBbeyBkYzonc2YnLCBzOiAxIH0seyBkYzonbWEnLCBzOiAyIH1dKSlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkuc2V0UmVhZFByZWZlcmVuY2UoJ3ByaW1hcnknKSAvLyBhbGlhcyBvZiAucmVhZCgpXG4gKlxuICogIyMjIyBQcmVmZXJlbmNlczpcbiAqXG4gKiAgICAgcHJpbWFyeSAtIChkZWZhdWx0KSAgUmVhZCBmcm9tIHByaW1hcnkgb25seS4gT3BlcmF0aW9ucyB3aWxsIHByb2R1Y2UgYW4gZXJyb3IgaWYgcHJpbWFyeSBpcyB1bmF2YWlsYWJsZS4gQ2Fubm90IGJlIGNvbWJpbmVkIHdpdGggdGFncy5cbiAqICAgICBzZWNvbmRhcnkgICAgICAgICAgICBSZWFkIGZyb20gc2Vjb25kYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGVycm9yLlxuICogICAgIHByaW1hcnlQcmVmZXJyZWQgICAgIFJlYWQgZnJvbSBwcmltYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGEgc2Vjb25kYXJ5LlxuICogICAgIHNlY29uZGFyeVByZWZlcnJlZCAgIFJlYWQgZnJvbSBhIHNlY29uZGFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSByZWFkIGZyb20gdGhlIHByaW1hcnkuXG4gKiAgICAgbmVhcmVzdCAgICAgICAgICAgICAgQWxsIG9wZXJhdGlvbnMgcmVhZCBmcm9tIGFtb25nIHRoZSBuZWFyZXN0IGNhbmRpZGF0ZXMsIGJ1dCB1bmxpa2Ugb3RoZXIgbW9kZXMsIHRoaXMgb3B0aW9uIHdpbGwgaW5jbHVkZSBib3RoIHRoZSBwcmltYXJ5IGFuZCBhbGwgc2Vjb25kYXJpZXMgaW4gdGhlIHJhbmRvbSBzZWxlY3Rpb24uXG4gKlxuICogQWxpYXNlc1xuICpcbiAqICAgICBwICAgcHJpbWFyeVxuICogICAgIHBwICBwcmltYXJ5UHJlZmVycmVkXG4gKiAgICAgcyAgIHNlY29uZGFyeVxuICogICAgIHNwICBzZWNvbmRhcnlQcmVmZXJyZWRcbiAqICAgICBuICAgbmVhcmVzdFxuICpcbiAqIFJlYWQgbW9yZSBhYm91dCBob3cgdG8gdXNlIHJlYWQgcHJlZmVyZW5jZXMgW2hlcmVdKGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZSkgYW5kIFtoZXJlXShodHRwOi8vbW9uZ29kYi5naXRodWIuY29tL25vZGUtbW9uZ29kYi1uYXRpdmUvZHJpdmVyLWFydGljbGVzL2FuaW50cm9kdWN0aW9udG8xXzFhbmQyXzIuaHRtbCNyZWFkLXByZWZlcmVuY2VzKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWFkUHJlZmVyZW5jZX0gcHJlZiBvbmUgb2YgdGhlIGxpc3RlZCBwcmVmZXJlbmNlIG9wdGlvbnMgb3IgdGhlaXIgYWxpYXNlc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZVxuICogQHNlZSBkcml2ZXIgaHR0cDovL21vbmdvZGIuZ2l0aHViLmNvbS9ub2RlLW1vbmdvZGItbmF0aXZlL2RyaXZlci1hcnRpY2xlcy9hbmludHJvZHVjdGlvbnRvMV8xYW5kMl8yLmh0bWwjcmVhZC1wcmVmZXJlbmNlc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnJlYWQgPSBRdWVyeS5wcm90b3R5cGUuc2V0UmVhZFByZWZlcmVuY2UgPSBmdW5jdGlvbihwcmVmKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiAhUXVlcnkucHJvdG90eXBlLnJlYWQuZGVwcmVjYXRpb25XYXJuaW5nSXNzdWVkKSB7XG4gICAgY29uc29sZS5lcnJvcignRGVwcmVjYXRpb24gd2FybmluZzogXFwndGFnc1xcJyBhcmd1bWVudCBpcyBub3Qgc3VwcG9ydGVkIGFueW1vcmUgaW4gUXVlcnkucmVhZCgpIG1ldGhvZC4gUGxlYXNlIHVzZSBtb25nb2RiLlJlYWRQcmVmZXJlbmNlIG9iamVjdCBpbnN0ZWFkLicpO1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5yZWFkLmRlcHJlY2F0aW9uV2FybmluZ0lzc3VlZCA9IHRydWU7XG4gIH1cbiAgdGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gdXRpbHMucmVhZFByZWYocHJlZik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWFkQ29uY2VybiBvcHRpb24gZm9yIHRoZSBxdWVyeS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsb2NhbCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2wnKSAgLy8gc2FtZSBhcyBsb2NhbFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignYXZhaWxhYmxlJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignYScpICAvLyBzYW1lIGFzIGF2YWlsYWJsZVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbWFqb3JpdHknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdtJykgIC8vIHNhbWUgYXMgbWFqb3JpdHlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2xpbmVhcml6YWJsZScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2x6JykgLy8gc2FtZSBhcyBsaW5lYXJpemFibGVcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ3NuYXBzaG90JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybigncycpICAvLyBzYW1lIGFzIHNuYXBzaG90XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnIoJ3MnKSAvLyByIGlzIGFsaWFzIG9mIHJlYWRDb25jZXJuXG4gKlxuICpcbiAqICMjIyMgUmVhZCBDb25jZXJuIExldmVsOlxuICpcbiAqICAgICBsb2NhbCAgICAgICAgIE1vbmdvREIgMy4yKyBUaGUgcXVlcnkgcmV0dXJucyBmcm9tIHRoZSBpbnN0YW5jZSB3aXRoIG5vIGd1YXJhbnRlZSBndWFyYW50ZWUgdGhhdCB0aGUgZGF0YSBoYXMgYmVlbiB3cml0dGVuIHRvIGEgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0IG1lbWJlcnMgKGkuZS4gbWF5IGJlIHJvbGxlZCBiYWNrKS5cbiAqICAgICBhdmFpbGFibGUgICAgIE1vbmdvREIgMy42KyBUaGUgcXVlcnkgcmV0dXJucyBmcm9tIHRoZSBpbnN0YW5jZSB3aXRoIG5vIGd1YXJhbnRlZSBndWFyYW50ZWUgdGhhdCB0aGUgZGF0YSBoYXMgYmVlbiB3cml0dGVuIHRvIGEgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0IG1lbWJlcnMgKGkuZS4gbWF5IGJlIHJvbGxlZCBiYWNrKS5cbiAqICAgICBtYWpvcml0eSAgICAgIE1vbmdvREIgMy4yKyBUaGUgcXVlcnkgcmV0dXJucyB0aGUgZGF0YSB0aGF0IGhhcyBiZWVuIGFja25vd2xlZGdlZCBieSBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzLiBUaGUgZG9jdW1lbnRzIHJldHVybmVkIGJ5IHRoZSByZWFkIG9wZXJhdGlvbiBhcmUgZHVyYWJsZSwgZXZlbiBpbiB0aGUgZXZlbnQgb2YgZmFpbHVyZS5cbiAqICAgICBsaW5lYXJpemFibGUgIE1vbmdvREIgMy40KyBUaGUgcXVlcnkgcmV0dXJucyBkYXRhIHRoYXQgcmVmbGVjdHMgYWxsIHN1Y2Nlc3NmdWwgbWFqb3JpdHktYWNrbm93bGVkZ2VkIHdyaXRlcyB0aGF0IGNvbXBsZXRlZCBwcmlvciB0byB0aGUgc3RhcnQgb2YgdGhlIHJlYWQgb3BlcmF0aW9uLiBUaGUgcXVlcnkgbWF5IHdhaXQgZm9yIGNvbmN1cnJlbnRseSBleGVjdXRpbmcgd3JpdGVzIHRvIHByb3BhZ2F0ZSB0byBhIG1ham9yaXR5IG9mIHJlcGxpY2Egc2V0IG1lbWJlcnMgYmVmb3JlIHJldHVybmluZyByZXN1bHRzLlxuICogICAgIHNuYXBzaG90ICAgICAgTW9uZ29EQiA0LjArIE9ubHkgYXZhaWxhYmxlIGZvciBvcGVyYXRpb25zIHdpdGhpbiBtdWx0aS1kb2N1bWVudCB0cmFuc2FjdGlvbnMuIFVwb24gdHJhbnNhY3Rpb24gY29tbWl0IHdpdGggd3JpdGUgY29uY2VybiBcIm1ham9yaXR5XCIsIHRoZSB0cmFuc2FjdGlvbiBvcGVyYXRpb25zIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgcmVhZCBmcm9tIGEgc25hcHNob3Qgb2YgbWFqb3JpdHktY29tbWl0dGVkIGRhdGEuXG4gKlxuICogQWxpYXNlc1xuICpcbiAqICAgICBsICAgbG9jYWxcbiAqICAgICBhICAgYXZhaWxhYmxlXG4gKiAgICAgbSAgIG1ham9yaXR5XG4gKiAgICAgbHogIGxpbmVhcml6YWJsZVxuICogICAgIHMgICBzbmFwc2hvdFxuICpcbiAqIFJlYWQgbW9yZSBhYm91dCBob3cgdG8gdXNlIHJlYWQgY29uY2VybiBbaGVyZV0oaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2UvcmVhZC1jb25jZXJuLykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxldmVsIG9uZSBvZiB0aGUgbGlzdGVkIHJlYWQgY29uY2VybiBsZXZlbCBvciB0aGVpciBhbGlhc2VzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2UvcmVhZC1jb25jZXJuL1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnJlYWRDb25jZXJuID0gUXVlcnkucHJvdG90eXBlLnIgPSBmdW5jdGlvbihsZXZlbCkge1xuICB0aGlzLm9wdGlvbnMucmVhZENvbmNlcm4gPSB1dGlscy5yZWFkQ29uY2VybihsZXZlbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRhaWxhYmxlIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnRhaWxhYmxlKCkgPD09IHRydWVcbiAqICAgICBxdWVyeS50YWlsYWJsZSh0cnVlKVxuICogICAgIHF1ZXJ5LnRhaWxhYmxlKGZhbHNlKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdiBkZWZhdWx0cyB0byB0cnVlXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvVGFpbGFibGUrQ3Vyc29yc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudGFpbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdmFsaWRhdGUoJ3RhaWxhYmxlJyk7XG5cbiAgdGhpcy5vcHRpb25zLnRhaWxhYmxlID0gYXJndW1lbnRzLmxlbmd0aFxuICAgID8gISFhcmd1bWVudHNbMF1cbiAgICA6IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYG1vbmdvZGAgc2VydmVycywgb3IgdGFnIHNldCBvZiBgbW9uZ29kYCBzZXJ2ZXJzLFxuICogdGhhdCBtdXN0IGFja25vd2xlZGdlIHRoaXMgd3JpdGUgYmVmb3JlIHRoaXMgd3JpdGUgaXMgY29uc2lkZXJlZCBzdWNjZXNzZnVsLlxuICogVGhpcyBvcHRpb24gaXMgb25seSB2YWxpZCBmb3Igb3BlcmF0aW9ucyB0aGF0IHdyaXRlIHRvIHRoZSBkYXRhYmFzZTpcbiAqXG4gKiAtIGBkZWxldGVPbmUoKWBcbiAqIC0gYGRlbGV0ZU1hbnkoKWBcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBgd2AgdmFsdWUgaWYgaXQgaXMgc3BlY2lmaWVkIGluIHdyaXRlQ29uY2VybiBvcHRpb25zXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oMClcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oMSlcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oeyB3OiAxLCBqOiB0cnVlLCB3dGltZW91dDogMjAwMCB9KVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybignbWFqb3JpdHknKVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybignbScpIC8vIHNhbWUgYXMgbWFqb3JpdHlcbiAqICAgICBtcXVlcnkoKS53cml0ZUNvbmNlcm4oJ3RhZ1NldE5hbWUnKSAvLyBpZiB0aGUgdGFnIHNldCBpcyAnbScsIHVzZSAud3JpdGVDb25jZXJuKHsgdzogJ20nIH0pIGluc3RlYWRcbiAqICAgICBtcXVlcnkoKS53KDEpIC8vIHcgaXMgYWxpYXMgb2Ygd3JpdGVDb25jZXJuXG4gKlxuICogQG1ldGhvZCB3cml0ZUNvbmNlcm5cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xudW1iZXJ8b2JqZWN0fSBjb25jZXJuIDAgZm9yIGZpcmUtYW5kLWZvcmdldCwgMSBmb3IgYWNrbm93bGVkZ2VkIGJ5IG9uZSBzZXJ2ZXIsICdtYWpvcml0eScgZm9yIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCwgb3IgW2FueSBvZiB0aGUgbW9yZSBhZHZhbmNlZCBvcHRpb25zXShodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3LW9wdGlvbikuXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jdy1vcHRpb25cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53cml0ZUNvbmNlcm4gPSBRdWVyeS5wcm90b3R5cGUudyA9IGZ1bmN0aW9uIHdyaXRlQ29uY2Vybihjb25jZXJuKSB7XG4gIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbmNlcm4pIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjb25jZXJuLmopIHRoaXMub3B0aW9ucy5qID0gY29uY2Vybi5qO1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGNvbmNlcm4udykgdGhpcy5vcHRpb25zLncgPSBjb25jZXJuLnc7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uY2Vybi53dGltZW91dCkgdGhpcy5vcHRpb25zLnd0aW1lb3V0ID0gY29uY2Vybi53dGltZW91dDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMudyA9ICdtJyA9PT0gY29uY2VybiA/ICdtYWpvcml0eScgOiBjb25jZXJuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSB0aW1lIGxpbWl0LCBpbiBtaWxsaXNlY29uZHMsIGZvciB0aGUgd3JpdGUgY29uY2Vybi5cbiAqIElmIGBtcyA+IDFgLCBpdCBpcyBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIHRoaXMgd3JpdGVcbiAqIHRvIHByb3BhZ2F0ZSB0aHJvdWdoIHRoZSByZXBsaWNhIHNldCBiZWZvcmUgdGhpcyBvcGVyYXRpb24gZmFpbHMuXG4gKiBUaGUgZGVmYXVsdCBpcyBgMGAsIHdoaWNoIG1lYW5zIG5vIHRpbWVvdXQuXG4gKlxuICogVGhpcyBvcHRpb24gaXMgb25seSB2YWxpZCBmb3Igb3BlcmF0aW9ucyB0aGF0IHdyaXRlIHRvIHRoZSBkYXRhYmFzZTpcbiAqXG4gKiAtIGBkZWxldGVPbmUoKWBcbiAqIC0gYGRlbGV0ZU1hbnkoKWBcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIGB3dGltZW91dGAgdmFsdWUgaWYgaXQgaXMgc3BlY2lmaWVkIGluIHdyaXRlQ29uY2VyblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbXF1ZXJ5KCkudygyKS5qKHRydWUpLnd0aW1lb3V0KDIwMDApXG4gKlxuICogQG1ldGhvZCB3dGltZW91dFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBtcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnd0aW1lb3V0ID0gUXVlcnkucHJvdG90eXBlLndUaW1lb3V0ID0gZnVuY3Rpb24gd3RpbWVvdXQobXMpIHtcbiAgdGhpcy5vcHRpb25zLnd0aW1lb3V0ID0gbXM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgYW5vdGhlciBRdWVyeSBvciBjb25kaXRpb25zIG9iamVjdCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIFdoZW4gYSBRdWVyeSBpcyBwYXNzZWQsIGNvbmRpdGlvbnMsIGZpZWxkIHNlbGVjdGlvbiBhbmQgb3B0aW9ucyBhcmUgbWVyZ2VkLlxuICpcbiAqIEBwYXJhbSB7UXVlcnl8T2JqZWN0fSBzb3VyY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gIGlmICghc291cmNlKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICghUXVlcnkuY2FuTWVyZ2Uoc291cmNlKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50LiBFeHBlY3RlZCBpbnN0YW5jZW9mIG1xdWVyeSBvciBwbGFpbiBvYmplY3QnKTtcblxuICBpZiAoc291cmNlIGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICAvLyBpZiBzb3VyY2UgaGFzIGEgZmVhdHVyZSwgYXBwbHkgaXQgdG8gb3Vyc2VsdmVzXG5cbiAgICBpZiAoc291cmNlLl9jb25kaXRpb25zKSB7XG4gICAgICB1dGlscy5tZXJnZSh0aGlzLl9jb25kaXRpb25zLCBzb3VyY2UuX2NvbmRpdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UuX2ZpZWxkcykge1xuICAgICAgdGhpcy5fZmllbGRzIHx8ICh0aGlzLl9maWVsZHMgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZSh0aGlzLl9maWVsZHMsIHNvdXJjZS5fZmllbGRzKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLm9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyB8fCAodGhpcy5vcHRpb25zID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2UodGhpcy5vcHRpb25zLCBzb3VyY2Uub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5fdXBkYXRlRG9jKSB7XG4gICAgICB0aGlzLl91cGRhdGVEb2MgfHwgKHRoaXMuX3VwZGF0ZURvYyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlQ2xvbmUodGhpcy5fdXBkYXRlRG9jLCBzb3VyY2UuX3VwZGF0ZURvYyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5fZGlzdGluY3REb2MpIHtcbiAgICAgIHRoaXMuX2Rpc3RpbmN0RG9jID0gc291cmNlLl9kaXN0aW5jdERvYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHBsYWluIG9iamVjdFxuICB1dGlscy5tZXJnZSh0aGlzLl9jb25kaXRpb25zLCBzb3VyY2UpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5kcyBkb2N1bWVudHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5maW5kKClcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kKClcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kKHsgbmFtZTogJ0J1cm5pbmcgTGlnaHRzJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdmaW5kJztcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZmluZGAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmQoKSB7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgaWYgKHRoaXMuJHVzZVByb2plY3Rpb24pIHtcbiAgICBvcHRpb25zLnByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5maWVsZHMgPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH1cblxuICBkZWJ1ZygnX2ZpbmQnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZChjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHF1ZXJ5IGN1cnNvclxuICpcbiAqICMjIyMgRXhhbXBsZXM6XG4gKlxuICogICAgIHF1ZXJ5LmZpbmQoKS5jdXJzb3IoKTtcbiAqICAgICBxdWVyeS5jdXJzb3IoeyBuYW1lOiAnQnVybmluZyBMaWdodHMnIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge09iamVjdH0gY3Vyc29yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jdXJzb3IgPSBmdW5jdGlvbiBjdXJzb3IoY3JpdGVyaWEpIHtcbiAgaWYgKHRoaXMub3ApIHtcbiAgICBpZiAodGhpcy5vcCAhPT0gJ2ZpbmQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuY3Vyc29yIG9ubHkgc3VwcG9ydCAuZmluZCBtZXRob2QnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5kKGNyaXRlcmlhKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgaWYgKHRoaXMuJHVzZVByb2plY3Rpb24pIHtcbiAgICBvcHRpb25zLnByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5maWVsZHMgPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH1cblxuICBkZWJ1ZygnZmluZEN1cnNvcicsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZEN1cnNvcihjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhcyBhIGZpbmRPbmUoKSBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5maW5kT25lKCkud2hlcmUoJ25hbWUnLCAvXkJ1cm5pbmcvKTtcbiAqXG4gKiAgICAgcXVlcnkuZmluZE9uZSh7IG5hbWU6IC9eQnVybmluZy8gfSlcbiAqXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZSh7IG5hbWU6IC9eQnVybmluZy8gfSk7IC8vIGV4ZWN1dGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmUgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2ZpbmRPbmUnO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBmaW5kT25lYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmUoKSB7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgaWYgKHRoaXMuJHVzZVByb2plY3Rpb24pIHtcbiAgICBvcHRpb25zLnByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5maWVsZHMgPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gIH1cblxuICBkZWJ1ZygnZmluZE9uZScsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kT25lKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3R1ZXMgdGhlIHF1ZXJ5IGFzIGEgY291bnQoKSBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5jb3VudCgpLndoZXJlKCdjb2xvcicsICdibGFjaycpLmV4ZWMoKTtcbiAqXG4gKiAgICAgcXVlcnkuY291bnQoeyBjb2xvcjogJ2JsYWNrJyB9KVxuICpcbiAqICAgICBhd2FpdCBxdWVyeS5jb3VudCh7IGNvbG9yOiAnYmxhY2snIH0pO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBxdWVyeS53aGVyZSgnY29sb3InLCAnYmxhY2snKS5jb3VudCgpO1xuICogICAgIGNvbnNvbGUubG9nKCd0aGVyZSBhcmUgJWQga2l0dGVucycsIGNvdW50KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FnZ3JlZ2F0aW9uI0FnZ3JlZ2F0aW9uLUNvdW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnY291bnQnO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBjb3VudGAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fY291bnQgPSBhc3luYyBmdW5jdGlvbiBfY291bnQoKSB7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucyxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGRlYnVnKCdjb3VudCcsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5jb3VudChjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIG9yIGV4ZWN1dGVzIGEgZGlzdGluY3QoKSBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBkaXN0aW5jdChjcml0ZXJpYSwgZmllbGQpXG4gKiAgICAgZGlzdGluY3QoY3JpdGVyaWEsIGZpZWxkKVxuICogICAgIGF3YWl0IGRpc3RpbmN0KGZpZWxkKVxuICogICAgIGRpc3RpbmN0KGZpZWxkKVxuICogICAgIGF3YWl0IGRpc3RpbmN0KClcbiAqICAgICBkaXN0aW5jdCgpXG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtjcml0ZXJpYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmllbGRdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FnZ3JlZ2F0aW9uI0FnZ3JlZ2F0aW9uLURpc3RpbmN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5kaXN0aW5jdCA9IGZ1bmN0aW9uKGNyaXRlcmlhLCBmaWVsZCkge1xuICB0aGlzLm9wID0gJ2Rpc3RpbmN0JztcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBpZiAoIWZpZWxkICYmIHR5cGVvZiBjcml0ZXJpYSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWVsZCA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmaWVsZCkge1xuICAgIHRoaXMuX2Rpc3RpbmN0RG9jID0gZmllbGQ7XG4gIH1cblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZGlzdGluY3RgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2Rpc3RpbmN0ID0gYXN5bmMgZnVuY3Rpb24gX2Rpc3RpbmN0KCkge1xuICBpZiAoIXRoaXMuX2Rpc3RpbmN0RG9jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBmb3IgYGRpc3RpbmN0YCBoYXMgYmVlbiBkZWNsYXJlZCcpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zLFxuICAgICAgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgZGVidWcoJ2Rpc3RpbmN0JywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmRpc3RpbmN0KHRoaXMuX2Rpc3RpbmN0RG9jLCBjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiBgdXBkYXRlTWFueSgpYCBvcGVyYXRpb24uIFRoaXMgZnVuY3Rpb24gd2lsbCB1cGRhdGUgX2FsbF8gZG9jdW1lbnRzIHRoYXQgbWF0Y2hcbiAqIGBjcml0ZXJpYWAsIHJhdGhlciB0aGFuIGp1c3QgdGhlIGZpcnN0IG9uZS5cbiAqXG4gKiBfQWxsIHBhdGhzIHBhc3NlZCB0aGF0IGFyZSBub3QgJGF0b21pYyBvcGVyYXRpb25zIHdpbGwgYmVjb21lICRzZXQgb3BzLl9cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFVwZGF0ZSBldmVyeSBkb2N1bWVudCB3aG9zZSBgdGl0bGVgIGNvbnRhaW5zICd0ZXN0J1xuICogICAgIG1xdWVyeSgpLnVwZGF0ZU1hbnkoeyB0aXRsZTogL3Rlc3QvIH0sIHsgeWVhcjogMjAxNyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY10gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudXBkYXRlTWFueSA9IGZ1bmN0aW9uIHVwZGF0ZU1hbnkoY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGRvYyA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVNYW55JywgY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYHVwZGF0ZU1hbnlgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZU1hbnkgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF91cGRhdGVFeGVjKHRoaXMsICd1cGRhdGVNYW55Jyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiBgdXBkYXRlT25lKClgIG9wZXJhdGlvbi4gVGhpcyBmdW5jdGlvbiB3aWxsIF9hbHdheXNfIHVwZGF0ZSBqdXN0IG9uZSBkb2N1bWVudCxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlIGBtdWx0aWAgb3B0aW9uLlxuICpcbiAqIF9BbGwgcGF0aHMgcGFzc2VkIHRoYXQgYXJlIG5vdCAkYXRvbWljIG9wZXJhdGlvbnMgd2lsbCBiZWNvbWUgJHNldCBvcHMuX1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVXBkYXRlIHRoZSBmaXJzdCBkb2N1bWVudCB3aG9zZSBgdGl0bGVgIGNvbnRhaW5zICd0ZXN0J1xuICogICAgIG1xdWVyeSgpLnVwZGF0ZU1hbnkoeyB0aXRsZTogL3Rlc3QvIH0sIHsgeWVhcjogMjAxNyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY10gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBkb2MgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAndXBkYXRlT25lJywgY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYHVwZGF0ZU9uZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fdXBkYXRlT25lID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfdXBkYXRlRXhlYyh0aGlzLCAndXBkYXRlT25lJyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiBgcmVwbGFjZU9uZSgpYCBvcGVyYXRpb24uIFNpbWlsYXJcbiAqIHRvIGB1cGRhdGVPbmUoKWAsIGV4Y2VwdCBgcmVwbGFjZU9uZSgpYCBpcyBub3QgYWxsb3dlZCB0byB1c2UgYXRvbWljXG4gKiBtb2RpZmllcnMgKGAkc2V0YCwgYCRwdXNoYCwgZXRjLikuIENhbGxpbmcgYHJlcGxhY2VPbmUoKWAgd2lsbCBhbHdheXNcbiAqIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGRvYy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFJlcGxhY2UgdGhlIGRvY3VtZW50IHdpdGggYF9pZGAgMSB3aXRoIGB7IF9pZDogMSwgeWVhcjogMjAxNyB9YFxuICogICAgIG1xdWVyeSgpLnJlcGxhY2VPbmUoeyBfaWQ6IDEgfSwgeyB5ZWFyOiAyMDE3IH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXSB0aGUgdXBkYXRlIGNvbW1hbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZXBsYWNlT25lID0gZnVuY3Rpb24gcmVwbGFjZU9uZShjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZG9jID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGhpcy5zZXRPcHRpb25zKHsgb3ZlcndyaXRlOiB0cnVlIH0pO1xuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAncmVwbGFjZU9uZScsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGByZXBsYWNlT25lYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9yZXBsYWNlT25lID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfdXBkYXRlRXhlYyh0aGlzLCAncmVwbGFjZU9uZScpO1xufTtcblxuLyohXG4gKiBJbnRlcm5hbCBoZWxwZXIgZm9yIHVwZGF0ZU1hbnksIHVwZGF0ZU9uZVxuICovXG5cbmZ1bmN0aW9uIF91cGRhdGUocXVlcnksIG9wLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIHF1ZXJ5Lm9wID0gb3A7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHF1ZXJ5Lm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIGlmIChkb2MpIHtcbiAgICBxdWVyeS5fbWVyZ2VVcGRhdGUoZG9jKTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc09iamVjdChvcHRpb25zKSkge1xuICAgIC8vIHsgb3ZlcndyaXRlOiB0cnVlIH1cbiAgICBxdWVyeS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgZGUtZHVwbGljYXRpbmcgXCJ1cGRhdGUqXCIgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeSBUaGUgUXVlcnkgT2JqZWN0IChyZXBsYWNlbWVudCBmb3IgXCJ0aGlzXCIpXG4gKiBAcGFyYW0ge1N0cmluZ30gb3AgVGhlIE9wZXJhdGlvbiB0byBiZSBkb25lXG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5hc3luYyBmdW5jdGlvbiBfdXBkYXRlRXhlYyhxdWVyeSwgb3ApIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHF1ZXJ5Ll9vcHRpb25zRm9yRXhlYygpO1xuXG4gIGNvbnN0IGNyaXRlcmlhID0gcXVlcnkuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IGRvYyA9IHF1ZXJ5Ll91cGRhdGVGb3JFeGVjKCk7XG5cbiAgZGVidWcoJ3VwZGF0ZScsIHF1ZXJ5Ll9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcblxuICByZXR1cm4gcXVlcnkuX2NvbGxlY3Rpb25bb3BdKGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhIGBkZWxldGVPbmUoKWAgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgbXF1ZXJ5KGNvbGxlY3Rpb24pLmRlbGV0ZU9uZSh7IGFydGlzdDogJ0FubmUgTXVycmF5JyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5kZWxldGVPbmUgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2RlbGV0ZU9uZSc7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGRlbGV0ZU9uZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZGVsZXRlT25lID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICBkZWxldGUgb3B0aW9ucy5qdXN0T25lO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICBkZWJ1ZygnZGVsZXRlT25lJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmRlbGV0ZU9uZShjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhIGBkZWxldGVNYW55KClgIG9wZXJhdGlvbi4gQWx3YXlzIGRlbGV0ZXNcbiAqIF9ldmVyeV8gZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGBjcml0ZXJpYWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBtcXVlcnkoY29sbGVjdGlvbikuZGVsZXRlTWFueSh7IGFydGlzdDogJ0FubmUgTXVycmF5JyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5kZWxldGVNYW55ID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdkZWxldGVNYW55JztcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZGVsZXRlTWFueWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZGVsZXRlTWFueSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgZGVsZXRlIG9wdGlvbnMuanVzdE9uZTtcblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG5cbiAgZGVidWcoJ2RlbGV0ZU9uZScsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5kZWxldGVNYW55KGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBbZmluZEFuZE1vZGlmeV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZmluZEFuZE1vZGlmeStDb21tYW5kKSB1cGRhdGUgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCB1cGRhdGVzIGl0IGFjY29yZGluZyB0byB0aGUgYHVwZGF0ZWAgYXJnLCBwYXNzaW5nIGFueSBgb3B0aW9uc2AsIGFuZCByZXR1cm5zIHRoZSBmb3VuZCBkb2N1bWVudCAoaWYgYW55KS5cbiAqXG4gKiAjIyMjIEF2YWlsYWJsZSBvcHRpb25zXG4gKlxuICogLSBgbmV3YDogYm9vbCAtIHRydWUgdG8gcmV0dXJuIHRoZSBtb2RpZmllZCBkb2N1bWVudCByYXRoZXIgdGhhbiB0aGUgb3JpZ2luYWwuIGRlZmF1bHRzIHRvIHRydWVcbiAqIC0gYHVwc2VydGA6IGJvb2wgLSBjcmVhdGVzIHRoZSBvYmplY3QgaWYgaXQgZG9lc24ndCBleGlzdC4gZGVmYXVsdHMgdG8gZmFsc2UuXG4gKiAtIGBzb3J0YDogaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGVcbiAqXG4gKiAjIyMjIEV4YW1wbGVzOlxuICpcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucykgLy8gZXhlY3V0ZXNcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSkgLy8gZXhlY3V0ZXNcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lQW5kVXBkYXRlKHVwZGF0ZSkgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUodXBkYXRlKSAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoKSAgICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGVzXG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtxdWVyeV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL2ZpbmRBbmRNb2RpZnkrQ29tbWFuZFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmRVcGRhdGUgPSBmdW5jdGlvbihjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIHRoaXMub3AgPSAnZmluZE9uZUFuZFVwZGF0ZSc7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBkb2MgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICAvLyBhcHBseSBkb2NcbiAgaWYgKGRvYykge1xuICAgIHRoaXMuX21lcmdlVXBkYXRlKGRvYyk7XG4gIH1cblxuICBvcHRpb25zICYmIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZmluZE9uZUFuZFVwZGF0ZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZUFuZFVwZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZUZvckV4ZWMoKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZE9uZUFuZFVwZGF0ZShjb25kcywgdXBkYXRlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBbZmluZEFuZE1vZGlmeV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZmluZEFuZE1vZGlmeStDb21tYW5kKSByZW1vdmUgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZW1vdmVzIGl0LCByZXR1cm5pbmcgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqICMjIyMgQXZhaWxhYmxlIG9wdGlvbnNcbiAqXG4gKiAtIGBzb3J0YDogaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGVcbiAqXG4gKiAjIyMjIEV4YW1wbGVzOlxuICpcbiAqICAgICBhd2FpdCBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZShjb25kaXRpb25zLCBvcHRpb25zKSAvLyBleGVjdXRlc1xuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMsIG9wdGlvbnMpICAvLyByZXR1cm4gUXVlcnlcbiAqICAgICBhd2FpdCBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZShjb25kaXRpb25zKSAvLyBleGVjdXRlc1xuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMpIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBhd2FpdCBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZSgpICAgLy8gZXhlY3V0ZXNcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmREZWxldGUoKSAgICAgICAgICAgLy8gYWxpYXMgb2YgLmZpbmRPbmVBbmRSZW1vdmUoKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZmluZEFuZE1vZGlmeStDb21tYW5kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kUmVtb3ZlID0gUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmREZWxldGUgPSBmdW5jdGlvbihjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIHRoaXMub3AgPSAnZmluZE9uZUFuZFJlbW92ZSc7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgLy8gYXBwbHkgY29uZGl0aW9uc1xuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY29uZGl0aW9ucykpIHtcbiAgICB0aGlzLm1lcmdlKGNvbmRpdGlvbnMpO1xuICB9XG5cbiAgLy8gYXBwbHkgb3B0aW9uc1xuICBvcHRpb25zICYmIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZmluZE9uZUFuZFJlbW92ZWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZUFuZFJlbW92ZSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRPbmVBbmREZWxldGUoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBBZGQgdHJhY2UgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBxdWVyeSBpcyBleGVjdXRlZC5cbiAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIChtZXRob2QsIHF1ZXJ5SW5mbywgcXVlcnkpIGFuZFxuICogc2hvdWxkIHJldHVybiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkXG4gKiB3aXRoIChlcnIsIHJlc3VsdCwgbWlsbGlzKSB3aGVuIHRoZSBxdWVyeSBpcyBjb21wbGV0ZS5cbiAqXG4gKiBxdWVyeUluZm8gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmc6IHtcbiAqICAgY29sbGVjdGlvbk5hbWU6IDxuYW1lIG9mIHRoZSBjb2xsZWN0aW9uPixcbiAqICAgY29uZGl0aW9uczogPHF1ZXJ5IGNyaXRlcmlhPixcbiAqICAgb3B0aW9uczogPGNvbW1lbnQsIGZpZWxkcywgcmVhZFByZWZlcmVuY2UsIGV0Yz4sXG4gKiAgIGRvYzogW2RvY3VtZW50IHRvIHVwZGF0ZSwgaWYgYXBwbGljYWJsZV1cbiAqIH1cbiAqXG4gKiBOT1RFOiBEb2VzIG5vdCB0cmFjZSBzdHJlYW0gcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFjZUZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUXVlcnkucHJvdG90eXBlLnNldFRyYWNlRnVuY3Rpb24gPSBmdW5jdGlvbih0cmFjZUZ1bmN0aW9uKSB7XG4gIHRoaXMuX3RyYWNlRnVuY3Rpb24gPSB0cmFjZUZ1bmN0aW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5XG4gKlxuICogIyMjIyBFeGFtcGxlczpcbiAqXG4gKiAgICAgcXVlcnkuZXhlYygpO1xuICogICAgIGF3YWl0IHF1ZXJ5LmV4ZWMoKTtcbiAqICAgICBxdWVyeS5leGVjKCd1cGRhdGUnKTtcbiAqICAgICBhd2FpdCBxdWVyeS5leGVjKCdmaW5kJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcGVyYXRpb25dXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5leGVjID0gYXN5bmMgZnVuY3Rpb24gZXhlYyhvcCkge1xuICBpZiAodHlwZW9mIG9wID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMub3AgPSBvcDtcbiAgfVxuXG4gIGFzc2VydC5vayh0aGlzLm9wLCAnTWlzc2luZyBxdWVyeSB0eXBlOiAoZmluZCwgZXRjKScpO1xuXG4gIGNvbnN0IGZuTmFtZSA9ICdfJyArIHRoaXMub3A7XG5cbiAgLy8gYmV0dGVyIGVycm9yLCBiZWNhdXNlIGRlZmF1bHQgd291bGQgbGlzdCBpdCBhcyBcInRoaXNbZm5OYW1lXSBpcyBub3QgYSBmdW5jdGlvblwiXG4gIGlmICh0eXBlb2YgdGhpc1tmbk5hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdGhpc1ske2ZuTmFtZX1dIGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gIH1cblxuICByZXR1cm4gdGhpc1tmbk5hbWVdKCk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSByZXR1cm5pbmcgYSBgUHJvbWlzZWAgd2hpY2ggd2lsbCBiZVxuICogcmVzb2x2ZWQgd2l0aCBlaXRoZXIgdGhlIGRvYyhzKSBvciByZWplY3RlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudGhlbiA9IGFzeW5jIGZ1bmN0aW9uKHJlcywgcmVqKSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoKS50aGVuKHJlcywgcmVqKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGN1cnNvciBmb3IgdGhlIGdpdmVuIGBmaW5kYCBxdWVyeS5cbiAqXG4gKiBAdGhyb3dzIEVycm9yIGlmIG9wZXJhdGlvbiBpcyBub3QgYSBmaW5kXG4gKiBAcmV0dXJucyB7Q3Vyc29yfSBNb25nb0RCIGRyaXZlciBjdXJzb3JcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY3Vyc29yID0gZnVuY3Rpb24oKSB7XG4gIGlmICgnZmluZCcgIT0gdGhpcy5vcClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnNvcigpIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBmaW5kJyk7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICBpZiAodGhpcy4kdXNlUHJvamVjdGlvbikge1xuICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmZpZWxkcyA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfVxuXG4gIGRlYnVnKCdjdXJzb3InLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZEN1cnNvcihjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkID0gZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gIHJldHVybiAhISh0aGlzLl9maWVsZHMgJiYgT2JqZWN0LmtleXModGhpcy5fZmllbGRzKS5sZW5ndGggPiAwKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBpbmNsdXNpdmUgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogICAgIHF1ZXJ5LnNlbGVjdGVkSW5jbHVzaXZlbHkoKSAvLyBmYWxzZVxuICogICAgIHF1ZXJ5LnNlbGVjdCgnbmFtZScpXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpIC8vIHRydWVcbiAqICAgICBxdWVyeS5zZWxlY3RlZEV4bHVzaXZlbHkoKSAvLyBmYWxzZVxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3RlZEluY2x1c2l2ZWx5ID0gZnVuY3Rpb24gc2VsZWN0ZWRJbmNsdXNpdmVseSgpIHtcbiAgaWYgKCF0aGlzLl9maWVsZHMpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fZmllbGRzKTtcbiAgaWYgKDAgPT09IGtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoMCA9PT0gdGhpcy5fZmllbGRzW2tleV0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5fZmllbGRzW2tleV0gJiZcbiAgICAgICAgdHlwZW9mIHRoaXMuX2ZpZWxkc1trZXldID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0aGlzLl9maWVsZHNba2V5XS4kbWV0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGV4Y2x1c2l2ZSBmaWVsZCBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZS5cbiAqXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGx1c2l2ZWx5KCkgLy8gZmFsc2VcbiAqICAgICBxdWVyeS5zZWxlY3QoJy1uYW1lJylcbiAqICAgICBxdWVyeS5zZWxlY3RlZEV4bHVzaXZlbHkoKSAvLyB0cnVlXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpIC8vIGZhbHNlXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkRXhjbHVzaXZlbHkgPSBmdW5jdGlvbiBzZWxlY3RlZEV4Y2x1c2l2ZWx5KCkge1xuICBpZiAoIXRoaXMuX2ZpZWxkcykgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpO1xuICBpZiAoMCA9PT0ga2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICgwID09PSB0aGlzLl9maWVsZHNba2V5XSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIE1lcmdlcyBgZG9jYCB3aXRoIHRoZSBjdXJyZW50IHVwZGF0ZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fbWVyZ2VVcGRhdGUgPSBmdW5jdGlvbihkb2MpIHtcbiAgaWYgKCF0aGlzLl91cGRhdGVEb2MpIHRoaXMuX3VwZGF0ZURvYyA9IHt9O1xuICBpZiAoZG9jIGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICBpZiAoZG9jLl91cGRhdGVEb2MpIHtcbiAgICAgIHV0aWxzLm1lcmdlQ2xvbmUodGhpcy5fdXBkYXRlRG9jLCBkb2MuX3VwZGF0ZURvYyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHV0aWxzLm1lcmdlQ2xvbmUodGhpcy5fdXBkYXRlRG9jLCBkb2MpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fb3B0aW9uc0ZvckV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHV0aWxzLmNsb25lKHRoaXMub3B0aW9ucyk7XG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZpZWxkcyBzZWxlY3Rpb24gZm9yIHRoaXMgcXVlcnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9maWVsZHNGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1dGlscy5jbG9uZSh0aGlzLl9maWVsZHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gdXBkYXRlIGRvY3VtZW50IHdpdGggY29ycmVjdGVkICRzZXQgb3BlcmF0aW9ucy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZUZvckV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgdXBkYXRlID0gdXRpbHMuY2xvbmUodGhpcy5fdXBkYXRlRG9jKTtcbiAgY29uc3Qgb3BzID0gdXRpbHMua2V5cyh1cGRhdGUpO1xuICBjb25zdCByZXQgPSB7fTtcblxuICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcndyaXRlKSB7XG4gICAgICByZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgnJCcgIT09IG9wWzBdKSB7XG4gICAgICAvLyBmaXggdXAgJHNldCBzdWdhclxuICAgICAgaWYgKCFyZXQuJHNldCkge1xuICAgICAgICBpZiAodXBkYXRlLiRzZXQpIHtcbiAgICAgICAgICByZXQuJHNldCA9IHVwZGF0ZS4kc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC4kc2V0ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldC4kc2V0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICBpZiAoIX5vcHMuaW5kZXhPZignJHNldCcpKSBvcHMucHVzaCgnJHNldCcpO1xuICAgIH0gZWxzZSBpZiAoJyRzZXQnID09PSBvcCkge1xuICAgICAgaWYgKCFyZXQuJHNldCkge1xuICAgICAgICByZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY29tcGlsZWRVcGRhdGUgPSByZXQ7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBfcGF0aCBpcyBzZXQuXG4gKlxuICogQHBhcm1hbSB7U3RyaW5nfSBtZXRob2RcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2Vuc3VyZVBhdGggPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCF0aGlzLl9wYXRoKSB7XG4gICAgY29uc3QgbXNnID0gbWV0aG9kICsgJygpIG11c3QgYmUgdXNlZCBhZnRlciB3aGVyZSgpICdcbiAgICAgICAgICAgICAgICAgICAgICsgJ3doZW4gY2FsbGVkIHdpdGggdGhlc2UgYXJndW1lbnRzJztcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufTtcblxuLyohXG4gKiBQZXJtaXNzaW9uc1xuICovXG5cblF1ZXJ5LnBlcm1pc3Npb25zID0gcmVxdWlyZSgnLi9wZXJtaXNzaW9ucycpO1xuXG5RdWVyeS5faXNQZXJtaXR0ZWQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGNvbnN0IGRlbmllZCA9IFF1ZXJ5LnBlcm1pc3Npb25zW2JdO1xuICBpZiAoIWRlbmllZCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0cnVlICE9PSBkZW5pZWRbYV07XG59O1xuXG5RdWVyeS5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gIGxldCBmYWlsO1xuICBsZXQgdmFsaWRhdG9yO1xuXG4gIGlmICh1bmRlZmluZWQgPT09IGFjdGlvbikge1xuXG4gICAgdmFsaWRhdG9yID0gUXVlcnkucGVybWlzc2lvbnNbdGhpcy5vcF07XG4gICAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIHZhbGlkYXRvcikgcmV0dXJuIHRydWU7XG5cbiAgICBmYWlsID0gdmFsaWRhdG9yKHRoaXMpO1xuXG4gIH0gZWxzZSBpZiAoIVF1ZXJ5Ll9pc1Blcm1pdHRlZChhY3Rpb24sIHRoaXMub3ApKSB7XG4gICAgZmFpbCA9IGFjdGlvbjtcbiAgfVxuXG4gIGlmIChmYWlsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhaWwgKyAnIGNhbm5vdCBiZSB1c2VkIHdpdGggJyArIHRoaXMub3ApO1xuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYGNvbmRzYCBjYW4gYmUgbWVyZ2VkIHVzaW5nIGBtcXVlcnkoKS5tZXJnZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5RdWVyeS5jYW5NZXJnZSA9IGZ1bmN0aW9uKGNvbmRzKSB7XG4gIHJldHVybiBjb25kcyBpbnN0YW5jZW9mIFF1ZXJ5IHx8IHV0aWxzLmlzT2JqZWN0KGNvbmRzKTtcbn07XG5cbi8qKlxuICogU2V0IGEgdHJhY2UgZnVuY3Rpb24gdGhhdCB3aWxsIGdldCBjYWxsZWQgd2hlbmV2ZXIgYVxuICogcXVlcnkgaXMgZXhlY3V0ZWQuXG4gKlxuICogU2VlIGBzZXRUcmFjZUZ1bmN0aW9uKClgIGZvciBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUXVlcnkuc2V0R2xvYmFsVHJhY2VGdW5jdGlvbiA9IGZ1bmN0aW9uKHRyYWNlRnVuY3Rpb24pIHtcbiAgUXVlcnkudHJhY2VGdW5jdGlvbiA9IHRyYWNlRnVuY3Rpb247XG59O1xuXG4vKiFcbiAqIEV4cG9ydHMuXG4gKi9cblxuUXVlcnkudXRpbHMgPSB1dGlscztcblF1ZXJ5LmVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG5RdWVyeS5Db2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5RdWVyeS5CYXNlQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9jb2xsZWN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBRdWVyeTtcblxuLy8gVE9ET1xuLy8gdGVzdCB1dGlsc1xuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJ1dGlsIiwidXRpbHMiLCJkZWJ1ZyIsIlF1ZXJ5IiwiY3JpdGVyaWEiLCJvcHRpb25zIiwicHJvdG8iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIm9wIiwidW5kZWZpbmVkIiwiT2JqZWN0IiwiYXNzaWduIiwiX2NvbmRpdGlvbnMiLCJjbG9uZSIsIl9maWVsZHMiLCJfdXBkYXRlRG9jIiwiX3BhdGgiLCJfZGlzdGluY3REb2MiLCJfY29sbGVjdGlvbiIsIl90cmFjZUZ1bmN0aW9uIiwic2V0T3B0aW9ucyIsImZpbmQiLCIkd2l0aGluQ21kIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJzZXQiLCJ2IiwidG9Db25zdHJ1Y3RvciIsIkN1c3RvbVF1ZXJ5IiwiY2FsbCIsImluaGVyaXRzIiwicCIsImlzT2JqZWN0IiwibWV0aG9kcyIsImtleXMiLCJtZXRob2QiLCJpIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiaXNBcnJheSIsImFwcGx5IiwiY29sbGVjdGlvbiIsImNvbGwiLCJDb2xsZWN0aW9uIiwiY29sbGF0aW9uIiwidmFsdWUiLCIkd2hlcmUiLCJqcyIsIndoZXJlIiwiYXJndW1lbnRzIiwidHlwZSIsIm1lcmdlIiwiVHlwZUVycm9yIiwiZXF1YWxzIiwidmFsIiwiX2Vuc3VyZVBhdGgiLCJwYXRoIiwiZXEiLCJvciIsImFycmF5IiwiJG9yIiwicHVzaCIsIm5vciIsIiRub3IiLCJhbmQiLCIkYW5kIiwic3BsaXQiLCJmb3JFYWNoIiwiJGNvbmRpdGlvbmFsIiwiY29uZHMiLCJtb2QiLCIkbW9kIiwiZXhpc3RzIiwiJGV4aXN0cyIsImVsZW1NYXRjaCIsImZuIiwiJGVsZW1NYXRjaCIsIndpdGhpbiIsIl9nZW9Db21wYXJpc29uIiwiYm94IiwicG9seWdvbiIsImFyZWEiLCJjZW50ZXIiLCJjaXJjbGUiLCJjb29yZGluYXRlcyIsImdlb21ldHJ5IiwiJGJveCIsImZyb20iLCJzaGlmdCIsIiRwb2x5Z29uIiwiRXJyb3IiLCJzcGhlcmljYWwiLCJ3S2V5IiwicmFkaXVzIiwiJHVuaXF1ZURvY3MiLCJ1bmlxdWUiLCJuZWFyIiwibWF4RGlzdGFuY2UiLCIkbWF4RGlzdGFuY2UiLCJtaW5EaXN0YW5jZSIsIiRtaW5EaXN0YW5jZSIsImZvcm1hdCIsIiRnZW9tZXRyeSIsImludGVyc2VjdHMiLCJzZWxlY3QiLCJhcmciLCJfdmFsaWRhdGUiLCJmaWVsZHMiLCJsZW4iLCJpc0FyZ3VtZW50c09iamVjdCIsImZpZWxkIiwiaW5jbHVkZSIsInN1YnN0cmluZyIsInNsaWNlIiwibnVtS2V5cyIsIm15RmllbGRzIiwiJHNsaWNlIiwic29ydCIsIl9wdXNoQXJyIiwiYXNjZW5kIiwiTWFwIiwiX3B1c2hNYXAiLCJfdmFsaWRTb3J0VmFsdWUiLCJhc2MiLCJhc2NlbmRpbmciLCJkZXNjIiwiZGVzY2VuZGluZyIsIm9wdHMiLCJzIiwiJG1ldGEiLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsIm1hcCIsImtleSIsIm1heFRpbWUiLCJtYXhUaW1lTVMiLCJtcyIsImhpbnQiLCJrIiwiaiIsInNsYXZlT2siLCJyZWFkIiwic2V0UmVhZFByZWZlcmVuY2UiLCJwcmVmIiwiZGVwcmVjYXRpb25XYXJuaW5nSXNzdWVkIiwiY29uc29sZSIsImVycm9yIiwicmVhZFByZWZlcmVuY2UiLCJyZWFkUHJlZiIsInJlYWRDb25jZXJuIiwiciIsImxldmVsIiwidGFpbGFibGUiLCJ3cml0ZUNvbmNlcm4iLCJ3IiwiY29uY2VybiIsInd0aW1lb3V0Iiwid1RpbWVvdXQiLCJzb3VyY2UiLCJjYW5NZXJnZSIsIm1lcmdlQ2xvbmUiLCJfZmluZCIsIl9vcHRpb25zRm9yRXhlYyIsIiR1c2VQcm9qZWN0aW9uIiwicHJvamVjdGlvbiIsIl9maWVsZHNGb3JFeGVjIiwiY29sbGVjdGlvbk5hbWUiLCJjdXJzb3IiLCJmaW5kQ3Vyc29yIiwiZmluZE9uZSIsIl9maW5kT25lIiwiY291bnQiLCJfY291bnQiLCJkaXN0aW5jdCIsIl9kaXN0aW5jdCIsInVwZGF0ZU1hbnkiLCJkb2MiLCJfdXBkYXRlIiwiX3VwZGF0ZU1hbnkiLCJfdXBkYXRlRXhlYyIsInVwZGF0ZU9uZSIsIl91cGRhdGVPbmUiLCJyZXBsYWNlT25lIiwib3ZlcndyaXRlIiwiX3JlcGxhY2VPbmUiLCJxdWVyeSIsIl9tZXJnZVVwZGF0ZSIsIl91cGRhdGVGb3JFeGVjIiwiZGVsZXRlT25lIiwiX2RlbGV0ZU9uZSIsImp1c3RPbmUiLCJkZWxldGVNYW55IiwiX2RlbGV0ZU1hbnkiLCJmaW5kT25lQW5kVXBkYXRlIiwiX2ZpbmRPbmVBbmRVcGRhdGUiLCJ1cGRhdGUiLCJmaW5kT25lQW5kUmVtb3ZlIiwiZmluZE9uZUFuZERlbGV0ZSIsImNvbmRpdGlvbnMiLCJfZmluZE9uZUFuZFJlbW92ZSIsInNldFRyYWNlRnVuY3Rpb24iLCJ0cmFjZUZ1bmN0aW9uIiwiZXhlYyIsIm9rIiwiZm5OYW1lIiwidGhlbiIsInJlcyIsInJlaiIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmNsdXNpdmVseSIsInNlbGVjdGVkRXhjbHVzaXZlbHkiLCJvcHMiLCJyZXQiLCIkc2V0IiwiaW5kZXhPZiIsIl9jb21waWxlZFVwZGF0ZSIsIm1zZyIsInBlcm1pc3Npb25zIiwiX2lzUGVybWl0dGVkIiwiYSIsImIiLCJkZW5pZWQiLCJhY3Rpb24iLCJmYWlsIiwidmFsaWRhdG9yIiwic2V0R2xvYmFsVHJhY2VGdW5jdGlvbiIsImVudiIsIkJhc2VDb2xsZWN0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/mquery.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/permissions.js":
/*!************************************************!*\
  !*** ./node_modules/mquery/lib/permissions.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst denied = exports;\ndenied.distinct = function(self) {\n    if (self._fields && Object.keys(self._fields).length > 0) {\n        return \"field selection and slice\";\n    }\n    const keys = Object.keys(denied.distinct);\n    let err;\n    keys.every(function(option) {\n        if (self.options[option]) {\n            err = option;\n            return false;\n        }\n        return true;\n    });\n    return err;\n};\ndenied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.hint = denied.distinct.tailable = true;\n// aggregation integration\ndenied.findOneAndUpdate = denied.findOneAndRemove = function(self) {\n    const keys = Object.keys(denied.findOneAndUpdate);\n    let err;\n    keys.every(function(option) {\n        if (self.options[option]) {\n            err = option;\n            return false;\n        }\n        return true;\n    });\n    return err;\n};\ndenied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.tailable = true;\ndenied.count = function(self) {\n    if (self._fields && Object.keys(self._fields).length > 0) {\n        return \"field selection and slice\";\n    }\n    const keys = Object.keys(denied.count);\n    let err;\n    keys.every(function(option) {\n        if (self.options[option]) {\n            err = option;\n            return false;\n        }\n        return true;\n    });\n    return err;\n};\ndenied.count.slice = denied.count.batchSize = denied.count.tailable = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9wZXJtaXNzaW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDO0FBRWZELE9BQU9FLFFBQVEsR0FBRyxTQUFTQyxJQUFJO0lBQzdCLElBQUlBLEtBQUtDLE9BQU8sSUFBSUMsT0FBT0MsSUFBSSxDQUFDSCxLQUFLQyxPQUFPLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ3hELE9BQU87SUFDVDtJQUVBLE1BQU1ELE9BQU9ELE9BQU9DLElBQUksQ0FBQ04sT0FBT0UsUUFBUTtJQUN4QyxJQUFJTTtJQUVKRixLQUFLRyxLQUFLLENBQUMsU0FBU0MsTUFBTTtRQUN4QixJQUFJUCxLQUFLUSxPQUFPLENBQUNELE9BQU8sRUFBRTtZQUN4QkYsTUFBTUU7WUFDTixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxPQUFPRjtBQUNUO0FBQ0FSLE9BQU9FLFFBQVEsQ0FBQ1UsTUFBTSxHQUN0QlosT0FBT0UsUUFBUSxDQUFDVyxLQUFLLEdBQ3JCYixPQUFPRSxRQUFRLENBQUNZLElBQUksR0FDcEJkLE9BQU9FLFFBQVEsQ0FBQ2EsS0FBSyxHQUNyQmYsT0FBT0UsUUFBUSxDQUFDYyxJQUFJLEdBQ3BCaEIsT0FBT0UsUUFBUSxDQUFDZSxTQUFTLEdBQ3pCakIsT0FBT0UsUUFBUSxDQUFDZ0IsSUFBSSxHQUNwQmxCLE9BQU9FLFFBQVEsQ0FBQ2lCLFFBQVEsR0FBRztBQUczQiwwQkFBMEI7QUFHMUJuQixPQUFPb0IsZ0JBQWdCLEdBQ3ZCcEIsT0FBT3FCLGdCQUFnQixHQUFHLFNBQVNsQixJQUFJO0lBQ3JDLE1BQU1HLE9BQU9ELE9BQU9DLElBQUksQ0FBQ04sT0FBT29CLGdCQUFnQjtJQUNoRCxJQUFJWjtJQUVKRixLQUFLRyxLQUFLLENBQUMsU0FBU0MsTUFBTTtRQUN4QixJQUFJUCxLQUFLUSxPQUFPLENBQUNELE9BQU8sRUFBRTtZQUN4QkYsTUFBTUU7WUFDTixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxPQUFPRjtBQUNUO0FBQ0FSLE9BQU9vQixnQkFBZ0IsQ0FBQ0wsS0FBSyxHQUM3QmYsT0FBT29CLGdCQUFnQixDQUFDSixJQUFJLEdBQzVCaEIsT0FBT29CLGdCQUFnQixDQUFDSCxTQUFTLEdBQ2pDakIsT0FBT29CLGdCQUFnQixDQUFDRCxRQUFRLEdBQUc7QUFHbkNuQixPQUFPc0IsS0FBSyxHQUFHLFNBQVNuQixJQUFJO0lBQzFCLElBQUlBLEtBQUtDLE9BQU8sSUFBSUMsT0FBT0MsSUFBSSxDQUFDSCxLQUFLQyxPQUFPLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ3hELE9BQU87SUFDVDtJQUVBLE1BQU1ELE9BQU9ELE9BQU9DLElBQUksQ0FBQ04sT0FBT3NCLEtBQUs7SUFDckMsSUFBSWQ7SUFFSkYsS0FBS0csS0FBSyxDQUFDLFNBQVNDLE1BQU07UUFDeEIsSUFBSVAsS0FBS1EsT0FBTyxDQUFDRCxPQUFPLEVBQUU7WUFDeEJGLE1BQU1FO1lBQ04sT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBRUEsT0FBT0Y7QUFDVDtBQUVBUixPQUFPc0IsS0FBSyxDQUFDVCxLQUFLLEdBQ2xCYixPQUFPc0IsS0FBSyxDQUFDTCxTQUFTLEdBQ3RCakIsT0FBT3NCLEtBQUssQ0FBQ0gsUUFBUSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWRtaW4vLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9wZXJtaXNzaW9ucy5qcz8zMmFkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVuaWVkID0gZXhwb3J0cztcblxuZGVuaWVkLmRpc3RpbmN0ID0gZnVuY3Rpb24oc2VsZikge1xuICBpZiAoc2VsZi5fZmllbGRzICYmIE9iamVjdC5rZXlzKHNlbGYuX2ZpZWxkcykubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnZmllbGQgc2VsZWN0aW9uIGFuZCBzbGljZSc7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVuaWVkLmRpc3RpbmN0KTtcbiAgbGV0IGVycjtcblxuICBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIGlmIChzZWxmLm9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgZXJyID0gb3B0aW9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5kZW5pZWQuZGlzdGluY3Quc2VsZWN0ID1cbmRlbmllZC5kaXN0aW5jdC5zbGljZSA9XG5kZW5pZWQuZGlzdGluY3Quc29ydCA9XG5kZW5pZWQuZGlzdGluY3QubGltaXQgPVxuZGVuaWVkLmRpc3RpbmN0LnNraXAgPVxuZGVuaWVkLmRpc3RpbmN0LmJhdGNoU2l6ZSA9XG5kZW5pZWQuZGlzdGluY3QuaGludCA9XG5kZW5pZWQuZGlzdGluY3QudGFpbGFibGUgPSB0cnVlO1xuXG5cbi8vIGFnZ3JlZ2F0aW9uIGludGVncmF0aW9uXG5cblxuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUgPVxuZGVuaWVkLmZpbmRPbmVBbmRSZW1vdmUgPSBmdW5jdGlvbihzZWxmKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZW5pZWQuZmluZE9uZUFuZFVwZGF0ZSk7XG4gIGxldCBlcnI7XG5cbiAga2V5cy5ldmVyeShmdW5jdGlvbihvcHRpb24pIHtcbiAgICBpZiAoc2VsZi5vcHRpb25zW29wdGlvbl0pIHtcbiAgICAgIGVyciA9IG9wdGlvbjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBlcnI7XG59O1xuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUubGltaXQgPVxuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUuc2tpcCA9XG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZS5iYXRjaFNpemUgPVxuZGVuaWVkLmZpbmRPbmVBbmRVcGRhdGUudGFpbGFibGUgPSB0cnVlO1xuXG5cbmRlbmllZC5jb3VudCA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgaWYgKHNlbGYuX2ZpZWxkcyAmJiBPYmplY3Qua2V5cyhzZWxmLl9maWVsZHMpLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ2ZpZWxkIHNlbGVjdGlvbiBhbmQgc2xpY2UnO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlbmllZC5jb3VudCk7XG4gIGxldCBlcnI7XG5cbiAga2V5cy5ldmVyeShmdW5jdGlvbihvcHRpb24pIHtcbiAgICBpZiAoc2VsZi5vcHRpb25zW29wdGlvbl0pIHtcbiAgICAgIGVyciA9IG9wdGlvbjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG5kZW5pZWQuY291bnQuc2xpY2UgPVxuZGVuaWVkLmNvdW50LmJhdGNoU2l6ZSA9XG5kZW5pZWQuY291bnQudGFpbGFibGUgPSB0cnVlO1xuIl0sIm5hbWVzIjpbImRlbmllZCIsImV4cG9ydHMiLCJkaXN0aW5jdCIsInNlbGYiLCJfZmllbGRzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImVyciIsImV2ZXJ5Iiwib3B0aW9uIiwib3B0aW9ucyIsInNlbGVjdCIsInNsaWNlIiwic29ydCIsImxpbWl0Iiwic2tpcCIsImJhdGNoU2l6ZSIsImhpbnQiLCJ0YWlsYWJsZSIsImZpbmRPbmVBbmRVcGRhdGUiLCJmaW5kT25lQW5kUmVtb3ZlIiwiY291bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/permissions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/mquery/lib/utils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*!\n * Module dependencies.\n */ const specialProperties = [\n    \"__proto__\",\n    \"constructor\",\n    \"prototype\"\n];\n/**\n * Clones objects\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */ const clone = exports.clone = function clone(obj, options) {\n    if (obj === undefined || obj === null) return obj;\n    if (Array.isArray(obj)) return exports.cloneArray(obj, options);\n    if (obj.constructor) {\n        if (/ObjectI[dD]$/.test(obj.constructor.name)) {\n            return \"function\" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.id);\n        }\n        if (obj.constructor.name === \"ReadPreference\") {\n            return new obj.constructor(obj.mode, clone(obj.tags, options));\n        }\n        if (\"Binary\" == obj._bsontype && obj.buffer && obj.value) {\n            return \"function\" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);\n        }\n        if (\"Date\" === obj.constructor.name || \"Function\" === obj.constructor.name) return new obj.constructor(+obj);\n        if (\"RegExp\" === obj.constructor.name) return new RegExp(obj);\n        if (\"Buffer\" === obj.constructor.name) return Buffer.from(obj);\n    }\n    if (isObject(obj)) return exports.cloneObject(obj, options);\n    if (obj.valueOf) return obj.valueOf();\n};\n/*!\n * ignore\n */ exports.cloneObject = function cloneObject(obj, options) {\n    const minimize = options && options.minimize, ret = {}, keys = Object.keys(obj), len = keys.length;\n    let hasKeys = false, val, k = \"\", i = 0;\n    for(i = 0; i < len; ++i){\n        k = keys[i];\n        // Not technically prototype pollution because this wouldn't merge properties\n        // onto `Object.prototype`, but avoid properties like __proto__ as a precaution.\n        if (specialProperties.indexOf(k) !== -1) {\n            continue;\n        }\n        val = clone(obj[k], options);\n        if (!minimize || \"undefined\" !== typeof val) {\n            hasKeys || (hasKeys = true);\n            ret[k] = val;\n        }\n    }\n    return minimize ? hasKeys && ret : ret;\n};\nexports.cloneArray = function cloneArray(arr, options) {\n    const ret = [], l = arr.length;\n    let i = 0;\n    for(; i < l; i++)ret.push(clone(arr[i], options));\n    return ret;\n};\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */ exports.merge = function merge(to, from) {\n    const keys = Object.keys(from);\n    for (const key of keys){\n        if (specialProperties.indexOf(key) !== -1) {\n            continue;\n        }\n        if (\"undefined\" === typeof to[key]) {\n            to[key] = from[key];\n        } else {\n            if (exports.isObject(from[key])) {\n                merge(to[key], from[key]);\n            } else {\n                to[key] = from[key];\n            }\n        }\n    }\n};\n/**\n * Same as merge but clones the assigned values.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */ exports.mergeClone = function mergeClone(to, from) {\n    const keys = Object.keys(from);\n    for (const key of keys){\n        if (specialProperties.indexOf(key) !== -1) {\n            continue;\n        }\n        if (\"undefined\" === typeof to[key]) {\n            to[key] = clone(from[key]);\n        } else {\n            if (exports.isObject(from[key])) {\n                mergeClone(to[key], from[key]);\n            } else {\n                to[key] = clone(from[key]);\n            }\n        }\n    }\n};\n/**\n * Read pref helper (mongo 2.2 drivers support this)\n *\n * Allows using aliases instead of full preference names:\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * @param {String} pref\n */ exports.readPref = function readPref(pref) {\n    switch(pref){\n        case \"p\":\n            pref = \"primary\";\n            break;\n        case \"pp\":\n            pref = \"primaryPreferred\";\n            break;\n        case \"s\":\n            pref = \"secondary\";\n            break;\n        case \"sp\":\n            pref = \"secondaryPreferred\";\n            break;\n        case \"n\":\n            pref = \"nearest\";\n            break;\n    }\n    return pref;\n};\n/**\n * Read Concern helper (mongo 3.2 drivers support this)\n *\n * Allows using string to specify read concern level:\n *\n *     local          3.2+\n *     available      3.6+\n *     majority       3.2+\n *     linearizable   3.4+\n *     snapshot       4.0+\n *\n * @param {String|Object} concern\n */ exports.readConcern = function readConcern(concern) {\n    if (\"string\" === typeof concern) {\n        switch(concern){\n            case \"l\":\n                concern = \"local\";\n                break;\n            case \"a\":\n                concern = \"available\";\n                break;\n            case \"m\":\n                concern = \"majority\";\n                break;\n            case \"lz\":\n                concern = \"linearizable\";\n                break;\n            case \"s\":\n                concern = \"snapshot\";\n                break;\n        }\n        concern = {\n            level: concern\n        };\n    }\n    return concern;\n};\n/**\n * Object.prototype.toString.call helper\n */ const _toString = Object.prototype.toString;\nexports.toString = function(arg) {\n    return _toString.call(arg);\n};\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n */ const isObject = exports.isObject = function(arg) {\n    return \"[object Object]\" == exports.toString(arg);\n};\n/**\n * Object.keys helper\n */ exports.keys = Object.keys;\n/**\n * Basic Object.create polyfill.\n * Only one argument is supported.\n *\n * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n */ exports.create = \"function\" == typeof Object.create ? Object.create : create;\nfunction create(proto) {\n    if (arguments.length > 1) {\n        throw new Error(\"Adding properties is not supported\");\n    }\n    function F() {}\n    F.prototype = proto;\n    return new F;\n}\n/**\n * inheritance\n */ exports.inherits = function(ctor, superCtor) {\n    ctor.prototype = exports.create(superCtor.prototype);\n    ctor.prototype.constructor = ctor;\n};\n/**\n * Check if this object is an arguments object\n *\n * @param {Any} v\n * @return {Boolean}\n */ exports.isArgumentsObject = function(v) {\n    return Object.prototype.toString.call(v) === \"[object Arguments]\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOztDQUVDLEdBRUQsTUFBTUEsb0JBQW9CO0lBQUM7SUFBYTtJQUFlO0NBQVk7QUFFbkU7Ozs7Ozs7Q0FPQyxHQUVELE1BQU1DLFFBQVFDLGFBQWEsR0FBRyxTQUFTRCxNQUFNRSxHQUFHLEVBQUVDLE9BQU87SUFDdkQsSUFBSUQsUUFBUUUsYUFBYUYsUUFBUSxNQUMvQixPQUFPQTtJQUVULElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0osTUFDaEIsT0FBT0QsUUFBUU0sVUFBVSxDQUFDTCxLQUFLQztJQUVqQyxJQUFJRCxJQUFJTSxXQUFXLEVBQUU7UUFDbkIsSUFBSSxlQUFlQyxJQUFJLENBQUNQLElBQUlNLFdBQVcsQ0FBQ0UsSUFBSSxHQUFHO1lBQzdDLE9BQU8sY0FBYyxPQUFPUixJQUFJRixLQUFLLEdBQ2pDRSxJQUFJRixLQUFLLEtBQ1QsSUFBSUUsSUFBSU0sV0FBVyxDQUFDTixJQUFJUyxFQUFFO1FBQ2hDO1FBRUEsSUFBSVQsSUFBSU0sV0FBVyxDQUFDRSxJQUFJLEtBQUssa0JBQWtCO1lBQzdDLE9BQU8sSUFBSVIsSUFBSU0sV0FBVyxDQUFDTixJQUFJVSxJQUFJLEVBQUVaLE1BQU1FLElBQUlXLElBQUksRUFBRVY7UUFDdkQ7UUFFQSxJQUFJLFlBQVlELElBQUlZLFNBQVMsSUFBSVosSUFBSWEsTUFBTSxJQUFJYixJQUFJYyxLQUFLLEVBQUU7WUFDeEQsT0FBTyxjQUFjLE9BQU9kLElBQUlGLEtBQUssR0FDakNFLElBQUlGLEtBQUssS0FDVCxJQUFJRSxJQUFJTSxXQUFXLENBQUNOLElBQUljLEtBQUssQ0FBQyxPQUFPZCxJQUFJZSxRQUFRO1FBQ3ZEO1FBRUEsSUFBSSxXQUFXZixJQUFJTSxXQUFXLENBQUNFLElBQUksSUFBSSxlQUFlUixJQUFJTSxXQUFXLENBQUNFLElBQUksRUFDeEUsT0FBTyxJQUFJUixJQUFJTSxXQUFXLENBQUMsQ0FB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QztBQUMvQztBQUVBOztDQUVDLEdBRURqRCxZQUFZLEdBQUcwQixPQUFPRCxJQUFJO0FBRTFCOzs7OztDQUtDLEdBRUR6QixjQUFjLEdBQUcsY0FBYyxPQUFPMEIsT0FBT3lCLE1BQU0sR0FDL0N6QixPQUFPeUIsTUFBTSxHQUNiQTtBQUVKLFNBQVNBLE9BQU9DLEtBQUs7SUFDbkIsSUFBSUMsVUFBVXpCLE1BQU0sR0FBRyxHQUFHO1FBQ3hCLE1BQU0sSUFBSTBCLE1BQU07SUFDbEI7SUFFQSxTQUFTQyxLQUFNO0lBQ2ZBLEVBQUVSLFNBQVMsR0FBR0s7SUFDZCxPQUFPLElBQUlHO0FBQ2I7QUFFQTs7Q0FFQyxHQUVEdkQsZ0JBQWdCLEdBQUcsU0FBU3lELElBQUksRUFBRUMsU0FBUztJQUN6Q0QsS0FBS1YsU0FBUyxHQUFHL0MsUUFBUW1ELE1BQU0sQ0FBQ08sVUFBVVgsU0FBUztJQUNuRFUsS0FBS1YsU0FBUyxDQUFDeEMsV0FBVyxHQUFHa0Q7QUFDL0I7QUFFQTs7Ozs7Q0FLQyxHQUVEekQseUJBQXlCLEdBQUcsU0FBUzRELENBQUM7SUFDcEMsT0FBT2xDLE9BQU9xQixTQUFTLENBQUNDLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDVSxPQUFPO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWRtaW4vLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi91dGlscy5qcz85NTVlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHNwZWNpYWxQcm9wZXJ0aWVzID0gWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ107XG5cbi8qKlxuICogQ2xvbmVzIG9iamVjdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjbG9uZWQgb2JqZWN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBjbG9uZSA9IGV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvYmosIG9wdGlvbnMpIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gb2JqO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpXG4gICAgcmV0dXJuIGV4cG9ydHMuY2xvbmVBcnJheShvYmosIG9wdGlvbnMpO1xuXG4gIGlmIChvYmouY29uc3RydWN0b3IpIHtcbiAgICBpZiAoL09iamVjdElbZERdJC8udGVzdChvYmouY29uc3RydWN0b3IubmFtZSkpIHtcbiAgICAgIHJldHVybiAnZnVuY3Rpb24nID09IHR5cGVvZiBvYmouY2xvbmVcbiAgICAgICAgPyBvYmouY2xvbmUoKVxuICAgICAgICA6IG5ldyBvYmouY29uc3RydWN0b3Iob2JqLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdSZWFkUHJlZmVyZW5jZScpIHtcbiAgICAgIHJldHVybiBuZXcgb2JqLmNvbnN0cnVjdG9yKG9iai5tb2RlLCBjbG9uZShvYmoudGFncywgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGlmICgnQmluYXJ5JyA9PSBvYmouX2Jzb250eXBlICYmIG9iai5idWZmZXIgJiYgb2JqLnZhbHVlKSB7XG4gICAgICByZXR1cm4gJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLmNsb25lXG4gICAgICAgID8gb2JqLmNsb25lKClcbiAgICAgICAgOiBuZXcgb2JqLmNvbnN0cnVjdG9yKG9iai52YWx1ZSh0cnVlKSwgb2JqLnN1Yl90eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoJ0RhdGUnID09PSBvYmouY29uc3RydWN0b3IubmFtZSB8fCAnRnVuY3Rpb24nID09PSBvYmouY29uc3RydWN0b3IubmFtZSlcbiAgICAgIHJldHVybiBuZXcgb2JqLmNvbnN0cnVjdG9yKCtvYmopO1xuXG4gICAgaWYgKCdSZWdFeHAnID09PSBvYmouY29uc3RydWN0b3IubmFtZSlcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKG9iaik7XG5cbiAgICBpZiAoJ0J1ZmZlcicgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG9iaik7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qob2JqKSlcbiAgICByZXR1cm4gZXhwb3J0cy5jbG9uZU9iamVjdChvYmosIG9wdGlvbnMpO1xuXG4gIGlmIChvYmoudmFsdWVPZilcbiAgICByZXR1cm4gb2JqLnZhbHVlT2YoKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5jbG9uZU9iamVjdCA9IGZ1bmN0aW9uIGNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucykge1xuICBjb25zdCBtaW5pbWl6ZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5taW5pbWl6ZSxcbiAgICAgIHJldCA9IHt9LFxuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iaiksXG4gICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGhhc0tleXMgPSBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICAgIGsgPSAnJyxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGsgPSBrZXlzW2ldO1xuICAgIC8vIE5vdCB0ZWNobmljYWxseSBwcm90b3R5cGUgcG9sbHV0aW9uIGJlY2F1c2UgdGhpcyB3b3VsZG4ndCBtZXJnZSBwcm9wZXJ0aWVzXG4gICAgLy8gb250byBgT2JqZWN0LnByb3RvdHlwZWAsIGJ1dCBhdm9pZCBwcm9wZXJ0aWVzIGxpa2UgX19wcm90b19fIGFzIGEgcHJlY2F1dGlvbi5cbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaW5kZXhPZihrKSAhPT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhbCA9IGNsb25lKG9ialtrXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIW1pbmltaXplIHx8ICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHZhbCkpIHtcbiAgICAgIGhhc0tleXMgfHwgKGhhc0tleXMgPSB0cnVlKTtcbiAgICAgIHJldFtrXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluaW1pemVcbiAgICA/IGhhc0tleXMgJiYgcmV0XG4gICAgOiByZXQ7XG59O1xuXG5leHBvcnRzLmNsb25lQXJyYXkgPSBmdW5jdGlvbiBjbG9uZUFycmF5KGFyciwgb3B0aW9ucykge1xuICBjb25zdCByZXQgPSBbXSxcbiAgICAgIGwgPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKVxuICAgIHJldC5wdXNoKGNsb25lKGFycltpXSwgb3B0aW9ucykpO1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBNZXJnZXMgYGZyb21gIGludG8gYHRvYCB3aXRob3V0IG92ZXJ3cml0aW5nIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRvLCBmcm9tKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0b1trZXldKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXhwb3J0cy5pc09iamVjdChmcm9tW2tleV0pKSB7XG4gICAgICAgIG1lcmdlKHRvW2tleV0sIGZyb21ba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTYW1lIGFzIG1lcmdlIGJ1dCBjbG9uZXMgdGhlIGFzc2lnbmVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm1lcmdlQ2xvbmUgPSBmdW5jdGlvbiBtZXJnZUNsb25lKHRvLCBmcm9tKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0b1trZXldKSB7XG4gICAgICB0b1trZXldID0gY2xvbmUoZnJvbVtrZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4cG9ydHMuaXNPYmplY3QoZnJvbVtrZXldKSkge1xuICAgICAgICBtZXJnZUNsb25lKHRvW2tleV0sIGZyb21ba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1trZXldID0gY2xvbmUoZnJvbVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVhZCBwcmVmIGhlbHBlciAobW9uZ28gMi4yIGRyaXZlcnMgc3VwcG9ydCB0aGlzKVxuICpcbiAqIEFsbG93cyB1c2luZyBhbGlhc2VzIGluc3RlYWQgb2YgZnVsbCBwcmVmZXJlbmNlIG5hbWVzOlxuICpcbiAqICAgICBwICAgcHJpbWFyeVxuICogICAgIHBwICBwcmltYXJ5UHJlZmVycmVkXG4gKiAgICAgcyAgIHNlY29uZGFyeVxuICogICAgIHNwICBzZWNvbmRhcnlQcmVmZXJyZWRcbiAqICAgICBuICAgbmVhcmVzdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmXG4gKi9cblxuZXhwb3J0cy5yZWFkUHJlZiA9IGZ1bmN0aW9uIHJlYWRQcmVmKHByZWYpIHtcbiAgc3dpdGNoIChwcmVmKSB7XG4gICAgY2FzZSAncCc6XG4gICAgICBwcmVmID0gJ3ByaW1hcnknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHAnOlxuICAgICAgcHJlZiA9ICdwcmltYXJ5UHJlZmVycmVkJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3MnOlxuICAgICAgcHJlZiA9ICdzZWNvbmRhcnknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3AnOlxuICAgICAgcHJlZiA9ICdzZWNvbmRhcnlQcmVmZXJyZWQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbic6XG4gICAgICBwcmVmID0gJ25lYXJlc3QnO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gcHJlZjtcbn07XG5cblxuLyoqXG4gKiBSZWFkIENvbmNlcm4gaGVscGVyIChtb25nbyAzLjIgZHJpdmVycyBzdXBwb3J0IHRoaXMpXG4gKlxuICogQWxsb3dzIHVzaW5nIHN0cmluZyB0byBzcGVjaWZ5IHJlYWQgY29uY2VybiBsZXZlbDpcbiAqXG4gKiAgICAgbG9jYWwgICAgICAgICAgMy4yK1xuICogICAgIGF2YWlsYWJsZSAgICAgIDMuNitcbiAqICAgICBtYWpvcml0eSAgICAgICAzLjIrXG4gKiAgICAgbGluZWFyaXphYmxlICAgMy40K1xuICogICAgIHNuYXBzaG90ICAgICAgIDQuMCtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmNlcm5cbiAqL1xuXG5leHBvcnRzLnJlYWRDb25jZXJuID0gZnVuY3Rpb24gcmVhZENvbmNlcm4oY29uY2Vybikge1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBjb25jZXJuKSB7XG4gICAgc3dpdGNoIChjb25jZXJuKSB7XG4gICAgICBjYXNlICdsJzpcbiAgICAgICAgY29uY2VybiA9ICdsb2NhbCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGNvbmNlcm4gPSAnYXZhaWxhYmxlJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgY29uY2VybiA9ICdtYWpvcml0eSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbHonOlxuICAgICAgICBjb25jZXJuID0gJ2xpbmVhcml6YWJsZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncyc6XG4gICAgICAgIGNvbmNlcm4gPSAnc25hcHNob3QnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uY2VybiA9IHsgbGV2ZWw6IGNvbmNlcm4gfTtcbiAgfVxuICByZXR1cm4gY29uY2Vybjtcbn07XG5cbi8qKlxuICogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsIGhlbHBlclxuICovXG5cbmNvbnN0IF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5leHBvcnRzLnRvU3RyaW5nID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChhcmcpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBhcmdgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8RnVuY3Rpb258UmVnRXhwfGFueX0gYXJnXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmNvbnN0IGlzT2JqZWN0ID0gZXhwb3J0cy5pc09iamVjdCA9IGZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gJ1tvYmplY3QgT2JqZWN0XScgPT0gZXhwb3J0cy50b1N0cmluZyhhcmcpO1xufTtcblxuLyoqXG4gKiBPYmplY3Qua2V5cyBoZWxwZXJcbiAqL1xuXG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cztcblxuLyoqXG4gKiBCYXNpYyBPYmplY3QuY3JlYXRlIHBvbHlmaWxsLlxuICogT25seSBvbmUgYXJndW1lbnQgaXMgc3VwcG9ydGVkLlxuICpcbiAqIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVxuICovXG5cbmV4cG9ydHMuY3JlYXRlID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgT2JqZWN0LmNyZWF0ZVxuICA/IE9iamVjdC5jcmVhdGVcbiAgOiBjcmVhdGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZShwcm90bykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZGluZyBwcm9wZXJ0aWVzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEYoKSB7IH1cbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuXG4vKipcbiAqIGluaGVyaXRhbmNlXG4gKi9cblxuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnByb3RvdHlwZSA9IGV4cG9ydHMuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUpO1xuICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIGFuIGFyZ3VtZW50cyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0FueX0gdlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG4iXSwibmFtZXMiOlsic3BlY2lhbFByb3BlcnRpZXMiLCJjbG9uZSIsImV4cG9ydHMiLCJvYmoiLCJvcHRpb25zIiwidW5kZWZpbmVkIiwiQXJyYXkiLCJpc0FycmF5IiwiY2xvbmVBcnJheSIsImNvbnN0cnVjdG9yIiwidGVzdCIsIm5hbWUiLCJpZCIsIm1vZGUiLCJ0YWdzIiwiX2Jzb250eXBlIiwiYnVmZmVyIiwidmFsdWUiLCJzdWJfdHlwZSIsIlJlZ0V4cCIsIkJ1ZmZlciIsImZyb20iLCJpc09iamVjdCIsImNsb25lT2JqZWN0IiwidmFsdWVPZiIsIm1pbmltaXplIiwicmV0Iiwia2V5cyIsIk9iamVjdCIsImxlbiIsImxlbmd0aCIsImhhc0tleXMiLCJ2YWwiLCJrIiwiaSIsImluZGV4T2YiLCJhcnIiLCJsIiwicHVzaCIsIm1lcmdlIiwidG8iLCJrZXkiLCJtZXJnZUNsb25lIiwicmVhZFByZWYiLCJwcmVmIiwicmVhZENvbmNlcm4iLCJjb25jZXJuIiwibGV2ZWwiLCJfdG9TdHJpbmciLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImFyZyIsImNhbGwiLCJjcmVhdGUiLCJwcm90byIsImFyZ3VtZW50cyIsIkVycm9yIiwiRiIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsImlzQXJndW1lbnRzT2JqZWN0IiwidiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/utils.js\n");

/***/ })

};
;