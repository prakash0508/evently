/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mpath";
exports.ids = ["vendor-chunks/mpath"];
exports.modules = {

/***/ "(ssr)/./node_modules/mpath/index.js":
/*!*************************************!*\
  !*** ./node_modules/mpath/index.js ***!
  \*************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = exports = __webpack_require__(/*! ./lib */ \"(ssr)/./node_modules/mpath/lib/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXBhdGgvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHQSxVQUFVQyxtQkFBT0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FkbWluLy4vbm9kZV9tb2R1bGVzL21wYXRoL2luZGV4LmpzPzE0NWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mpath/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mpath/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/mpath/lib/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint strict:off */ /* eslint no-var: off */ /* eslint no-redeclare: off */ var stringToParts = __webpack_require__(/*! ./stringToParts */ \"(ssr)/./node_modules/mpath/lib/stringToParts.js\");\n// These properties are special and can open client libraries to security\n// issues\nvar ignoreProperties = [\n    \"__proto__\",\n    \"constructor\",\n    \"prototype\"\n];\n/**\n * Returns the value of object `o` at the given `path`.\n *\n * ####Example:\n *\n *     var obj = {\n *         comments: [\n *             { title: 'exciting!', _doc: { title: 'great!' }}\n *           , { title: 'number dos' }\n *         ]\n *     }\n *\n *     mpath.get('comments.0.title', o)         // 'exciting!'\n *     mpath.get('comments.0.title', o, '_doc') // 'great!'\n *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']\n *\n *     // summary\n *     mpath.get(path, o)\n *     mpath.get(path, o, special)\n *     mpath.get(path, o, map)\n *     mpath.get(path, o, special, map)\n *\n * @param {String} path\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.\n */ exports.get = function(path, o, special, map) {\n    var lookup;\n    if (\"function\" == typeof special) {\n        if (special.length < 2) {\n            map = special;\n            special = undefined;\n        } else {\n            lookup = special;\n            special = undefined;\n        }\n    }\n    map || (map = K);\n    var parts = \"string\" == typeof path ? stringToParts(path) : path;\n    if (!Array.isArray(parts)) {\n        throw new TypeError(\"Invalid `path`. Must be either string or array\");\n    }\n    var obj = o, part;\n    for(var i = 0; i < parts.length; ++i){\n        part = parts[i];\n        if (typeof parts[i] !== \"string\" && typeof parts[i] !== \"number\") {\n            throw new TypeError(\"Each segment of path to `get()` must be a string or number, got \" + typeof parts[i]);\n        }\n        if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n            // reading a property from the array items\n            var paths = parts.slice(i);\n            // Need to `concat()` to avoid `map()` calling a constructor of an array\n            // subclass\n            return [].concat(obj).map(function(item) {\n                return item ? exports.get(paths, item, special || lookup, map) : map(undefined);\n            });\n        }\n        if (lookup) {\n            obj = lookup(obj, part);\n        } else {\n            var _from = special && obj[special] ? obj[special] : obj;\n            obj = _from instanceof Map ? _from.get(part) : _from[part];\n        }\n        if (!obj) return map(obj);\n    }\n    return map(obj);\n};\n/**\n * Returns true if `in` returns true for every piece of the path\n *\n * @param {String} path\n * @param {Object} o\n */ exports.has = function(path, o) {\n    var parts = typeof path === \"string\" ? stringToParts(path) : path;\n    if (!Array.isArray(parts)) {\n        throw new TypeError(\"Invalid `path`. Must be either string or array\");\n    }\n    var len = parts.length;\n    var cur = o;\n    for(var i = 0; i < len; ++i){\n        if (typeof parts[i] !== \"string\" && typeof parts[i] !== \"number\") {\n            throw new TypeError(\"Each segment of path to `has()` must be a string or number, got \" + typeof parts[i]);\n        }\n        if (cur == null || typeof cur !== \"object\" || !(parts[i] in cur)) {\n            return false;\n        }\n        cur = cur[parts[i]];\n    }\n    return true;\n};\n/**\n * Deletes the last piece of `path`\n *\n * @param {String} path\n * @param {Object} o\n */ exports.unset = function(path, o) {\n    var parts = typeof path === \"string\" ? stringToParts(path) : path;\n    if (!Array.isArray(parts)) {\n        throw new TypeError(\"Invalid `path`. Must be either string or array\");\n    }\n    var len = parts.length;\n    var cur = o;\n    for(var i = 0; i < len; ++i){\n        if (cur == null || typeof cur !== \"object\" || !(parts[i] in cur)) {\n            return false;\n        }\n        if (typeof parts[i] !== \"string\" && typeof parts[i] !== \"number\") {\n            throw new TypeError(\"Each segment of path to `unset()` must be a string or number, got \" + typeof parts[i]);\n        }\n        // Disallow any updates to __proto__ or special properties.\n        if (ignoreProperties.indexOf(parts[i]) !== -1) {\n            return false;\n        }\n        if (i === len - 1) {\n            delete cur[parts[i]];\n            return true;\n        }\n        cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];\n    }\n    return true;\n};\n/**\n * Sets the `val` at the given `path` of object `o`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.\n */ exports.set = function(path, val, o, special, map, _copying) {\n    var lookup;\n    if (\"function\" == typeof special) {\n        if (special.length < 2) {\n            map = special;\n            special = undefined;\n        } else {\n            lookup = special;\n            special = undefined;\n        }\n    }\n    map || (map = K);\n    var parts = \"string\" == typeof path ? stringToParts(path) : path;\n    if (!Array.isArray(parts)) {\n        throw new TypeError(\"Invalid `path`. Must be either string or array\");\n    }\n    if (null == o) return;\n    for(var i = 0; i < parts.length; ++i){\n        if (typeof parts[i] !== \"string\" && typeof parts[i] !== \"number\") {\n            throw new TypeError(\"Each segment of path to `set()` must be a string or number, got \" + typeof parts[i]);\n        }\n        // Silently ignore any updates to `__proto__`, these are potentially\n        // dangerous if using mpath with unsanitized data.\n        if (ignoreProperties.indexOf(parts[i]) !== -1) {\n            return;\n        }\n    }\n    // the existance of $ in a path tells us if the user desires\n    // the copying of an array instead of setting each value of\n    // the array to the one by one to matching positions of the\n    // current array. Unless the user explicitly opted out by passing\n    // false, see Automattic/mongoose#6273\n    var copy = _copying || /\\$/.test(path) && _copying !== false, obj = o, part;\n    for(var i = 0, len = parts.length - 1; i < len; ++i){\n        part = parts[i];\n        if (\"$\" == part) {\n            if (i == len - 1) {\n                break;\n            } else {\n                continue;\n            }\n        }\n        if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n            var paths = parts.slice(i);\n            if (!copy && Array.isArray(val)) {\n                for(var j = 0; j < obj.length && j < val.length; ++j){\n                    // assignment of single values of array\n                    exports.set(paths, val[j], obj[j], special || lookup, map, copy);\n                }\n            } else {\n                for(var j = 0; j < obj.length; ++j){\n                    // assignment of entire value\n                    exports.set(paths, val, obj[j], special || lookup, map, copy);\n                }\n            }\n            return;\n        }\n        if (lookup) {\n            obj = lookup(obj, part);\n        } else {\n            var _to = special && obj[special] ? obj[special] : obj;\n            obj = _to instanceof Map ? _to.get(part) : _to[part];\n        }\n        if (!obj) return;\n    }\n    // process the last property of the path\n    part = parts[len];\n    // use the special property if exists\n    if (special && obj[special]) {\n        obj = obj[special];\n    }\n    // set the value on the last branch\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n        if (!copy && Array.isArray(val)) {\n            _setArray(obj, val, part, lookup, special, map);\n        } else {\n            for(var j = 0; j < obj.length; ++j){\n                var item = obj[j];\n                if (item) {\n                    if (lookup) {\n                        lookup(item, part, map(val));\n                    } else {\n                        if (item[special]) item = item[special];\n                        item[part] = map(val);\n                    }\n                }\n            }\n        }\n    } else {\n        if (lookup) {\n            lookup(obj, part, map(val));\n        } else if (obj instanceof Map) {\n            obj.set(part, map(val));\n        } else {\n            obj[part] = map(val);\n        }\n    }\n};\n/*!\n * Split a string path into components delimited by '.' or\n * '[\\d+]'\n *\n * #### Example:\n *     stringToParts('foo[0].bar.1'); // ['foo', '0', 'bar', '1']\n */ exports.stringToParts = stringToParts;\n/*!\n * Recursively set nested arrays\n */ function _setArray(obj, val, part, lookup, special, map) {\n    for(var item, j = 0; j < obj.length && j < val.length; ++j){\n        item = obj[j];\n        if (Array.isArray(item) && Array.isArray(val[j])) {\n            _setArray(item, val[j], part, lookup, special, map);\n        } else if (item) {\n            if (lookup) {\n                lookup(item, part, map(val[j]));\n            } else {\n                if (item[special]) item = item[special];\n                item[part] = map(val[j]);\n            }\n        }\n    }\n}\n/*!\n * Returns the value passed to it.\n */ function K(v) {\n    return v;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXBhdGgvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixHQUNyQixzQkFBc0IsR0FDdEIsNEJBQTRCLEdBRTVCLElBQUlBLGdCQUFnQkMsbUJBQU9BLENBQUM7QUFFNUIseUVBQXlFO0FBQ3pFLFNBQVM7QUFDVCxJQUFJQyxtQkFBbUI7SUFBQztJQUFhO0lBQWU7Q0FBWTtBQUVoRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQkMsR0FFREMsV0FBVyxHQUFHLFNBQVNFLElBQUksRUFBRUMsQ0FBQyxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDMUMsSUFBSUM7SUFFSixJQUFJLGNBQWMsT0FBT0YsU0FBUztRQUNoQyxJQUFJQSxRQUFRRyxNQUFNLEdBQUcsR0FBRztZQUN0QkYsTUFBTUQ7WUFDTkEsVUFBVUk7UUFDWixPQUFPO1lBQ0xGLFNBQVNGO1lBQ1RBLFVBQVVJO1FBQ1o7SUFDRjtJQUVBSCxPQUFRQSxDQUFBQSxNQUFNSSxDQUFBQTtJQUVkLElBQUlDLFFBQVEsWUFBWSxPQUFPUixPQUMzQkwsY0FBY0ssUUFDZEE7SUFFSixJQUFJLENBQUNTLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTtRQUN6QixNQUFNLElBQUlHLFVBQVU7SUFDdEI7SUFFQSxJQUFJQyxNQUFNWCxHQUNOWTtJQUVKLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixNQUFNSCxNQUFNLEVBQUUsRUFBRVMsRUFBRztRQUNyQ0QsT0FBT0wsS0FBSyxDQUFDTSxFQUFFO1FBQ2YsSUFBSSxPQUFPTixLQUFLLENBQUNNLEVBQUUsS0FBSyxZQUFZLE9BQU9OLEtBQUssQ0FBQ00sRUFBRSxLQUFLLFVBQVU7WUFDaEUsTUFBTSxJQUFJSCxVQUFVLHFFQUFxRSxPQUFPSCxLQUFLLENBQUNNLEVBQUU7UUFDMUc7UUFFQSxJQUFJTCxNQUFNQyxPQUFPLENBQUNFLFFBQVEsQ0FBQyxRQUFRRyxJQUFJLENBQUNGLE9BQU87WUFDN0MsMENBQTBD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RUFBRUYsT0FBTyxFQUFFQyxHQUFHO0lBQ3JELElBQUssSUFBSWdCLE1BQU1ZLElBQUksR0FBR0EsSUFBSW5CLElBQUlQLE1BQU0sSUFBSTBCLElBQUlILElBQUl2QixNQUFNLEVBQUUsRUFBRTBCLEVBQUc7UUFDM0RaLE9BQU9QLEdBQUcsQ0FBQ21CLEVBQUU7UUFDYixJQUFJdEIsTUFBTUMsT0FBTyxDQUFDUyxTQUFTVixNQUFNQyxPQUFPLENBQUNrQixHQUFHLENBQUNHLEVBQUUsR0FBRztZQUNoREUsVUFBVWQsTUFBTVMsR0FBRyxDQUFDRyxFQUFFLEVBQUVsQixNQUFNVCxRQUFRRixTQUFTQztRQUNqRCxPQUFPLElBQUlnQixNQUFNO1lBQ2YsSUFBSWYsUUFBUTtnQkFDVkEsT0FBT2UsTUFBTU4sTUFBTVYsSUFBSXlCLEdBQUcsQ0FBQ0csRUFBRTtZQUMvQixPQUFPO2dCQUNMLElBQUlaLElBQUksQ0FBQ2pCLFFBQVEsRUFBRWlCLE9BQU9BLElBQUksQ0FBQ2pCLFFBQVE7Z0JBQ3ZDaUIsSUFBSSxDQUFDTixLQUFLLEdBQUdWLElBQUl5QixHQUFHLENBQUNHLEVBQUU7WUFDekI7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUVELFNBQVN4QixFQUFFMkIsQ0FBQztJQUNWLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZG1pbi8uL25vZGVfbW9kdWxlcy9tcGF0aC9saWIvaW5kZXguanM/N2RhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgc3RyaWN0Om9mZiAqL1xuLyogZXNsaW50IG5vLXZhcjogb2ZmICovXG4vKiBlc2xpbnQgbm8tcmVkZWNsYXJlOiBvZmYgKi9cblxudmFyIHN0cmluZ1RvUGFydHMgPSByZXF1aXJlKCcuL3N0cmluZ1RvUGFydHMnKTtcblxuLy8gVGhlc2UgcHJvcGVydGllcyBhcmUgc3BlY2lhbCBhbmQgY2FuIG9wZW4gY2xpZW50IGxpYnJhcmllcyB0byBzZWN1cml0eVxuLy8gaXNzdWVzXG52YXIgaWdub3JlUHJvcGVydGllcyA9IFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIG9iamVjdCBgb2AgYXQgdGhlIGdpdmVuIGBwYXRoYC5cbiAqXG4gKiAjIyMjRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgY29tbWVudHM6IFtcbiAqICAgICAgICAgICAgIHsgdGl0bGU6ICdleGNpdGluZyEnLCBfZG9jOiB7IHRpdGxlOiAnZ3JlYXQhJyB9fVxuICogICAgICAgICAgICwgeyB0aXRsZTogJ251bWJlciBkb3MnIH1cbiAqICAgICAgICAgXVxuICogICAgIH1cbiAqXG4gKiAgICAgbXBhdGguZ2V0KCdjb21tZW50cy4wLnRpdGxlJywgbykgICAgICAgICAvLyAnZXhjaXRpbmchJ1xuICogICAgIG1wYXRoLmdldCgnY29tbWVudHMuMC50aXRsZScsIG8sICdfZG9jJykgLy8gJ2dyZWF0ISdcbiAqICAgICBtcGF0aC5nZXQoJ2NvbW1lbnRzLnRpdGxlJywgbykgICAgICAgICAgIC8vIFsnZXhjaXRpbmchJywgJ251bWJlciBkb3MnXVxuICpcbiAqICAgICAvLyBzdW1tYXJ5XG4gKiAgICAgbXBhdGguZ2V0KHBhdGgsIG8pXG4gKiAgICAgbXBhdGguZ2V0KHBhdGgsIG8sIHNwZWNpYWwpXG4gKiAgICAgbXBhdGguZ2V0KHBhdGgsIG8sIG1hcClcbiAqICAgICBtcGF0aC5nZXQocGF0aCwgbywgc3BlY2lhbCwgbWFwKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICogQHBhcmFtIHtTdHJpbmd9IFtzcGVjaWFsXSBXaGVuIHRoaXMgcHJvcGVydHkgbmFtZSBpcyBwcmVzZW50IG9uIGFueSBvYmplY3QgaW4gdGhlIHBhdGgsIHdhbGtpbmcgd2lsbCBjb250aW51ZSBvbiB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFttYXBdIE9wdGlvbmFsIGZ1bmN0aW9uIHdoaWNoIHJlY2VpdmVzIGVhY2ggaW5kaXZpZHVhbCBmb3VuZCB2YWx1ZS4gVGhlIHZhbHVlIHJldHVybmVkIGZyb20gYG1hcGAgaXMgdXNlZCBpbiB0aGUgb3JpZ2luYWwgdmFsdWVzIHBsYWNlLlxuICovXG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24ocGF0aCwgbywgc3BlY2lhbCwgbWFwKSB7XG4gIHZhciBsb29rdXA7XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHNwZWNpYWwpIHtcbiAgICBpZiAoc3BlY2lhbC5sZW5ndGggPCAyKSB7XG4gICAgICBtYXAgPSBzcGVjaWFsO1xuICAgICAgc3BlY2lhbCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9va3VwID0gc3BlY2lhbDtcbiAgICAgIHNwZWNpYWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgbWFwIHx8IChtYXAgPSBLKTtcblxuICB2YXIgcGFydHMgPSAnc3RyaW5nJyA9PSB0eXBlb2YgcGF0aFxuICAgID8gc3RyaW5nVG9QYXJ0cyhwYXRoKVxuICAgIDogcGF0aDtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocGFydHMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBgcGF0aGAuIE11c3QgYmUgZWl0aGVyIHN0cmluZyBvciBhcnJheScpO1xuICB9XG5cbiAgdmFyIG9iaiA9IG8sXG4gICAgICBwYXJ0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHR5cGVvZiBwYXJ0c1tpXSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHBhcnRzW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBzZWdtZW50IG9mIHBhdGggdG8gYGdldCgpYCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlciwgZ290ICcgKyB0eXBlb2YgcGFydHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgJiYgIS9eXFxkKyQvLnRlc3QocGFydCkpIHtcbiAgICAgIC8vIHJlYWRpbmcgYSBwcm9wZXJ0eSBmcm9tIHRoZSBhcnJheSBpdGVtc1xuICAgICAgdmFyIHBhdGhzID0gcGFydHMuc2xpY2UoaSk7XG5cbiAgICAgIC8vIE5lZWQgdG8gYGNvbmNhdCgpYCB0byBhdm9pZCBgbWFwKClgIGNhbGxpbmcgYSBjb25zdHJ1Y3RvciBvZiBhbiBhcnJheVxuICAgICAgLy8gc3ViY2xhc3NcbiAgICAgIHJldHVybiBbXS5jb25jYXQob2JqKS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgID8gZXhwb3J0cy5nZXQocGF0aHMsIGl0ZW0sIHNwZWNpYWwgfHwgbG9va3VwLCBtYXApXG4gICAgICAgICAgOiBtYXAodW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsb29rdXApIHtcbiAgICAgIG9iaiA9IGxvb2t1cChvYmosIHBhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2Zyb20gPSBzcGVjaWFsICYmIG9ialtzcGVjaWFsXSA/IG9ialtzcGVjaWFsXSA6IG9iajtcbiAgICAgIG9iaiA9IF9mcm9tIGluc3RhbmNlb2YgTWFwID9cbiAgICAgICAgX2Zyb20uZ2V0KHBhcnQpIDpcbiAgICAgICAgX2Zyb21bcGFydF07XG4gICAgfVxuXG4gICAgaWYgKCFvYmopIHJldHVybiBtYXAob2JqKTtcbiAgfVxuXG4gIHJldHVybiBtYXAob2JqKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBpbmAgcmV0dXJucyB0cnVlIGZvciBldmVyeSBwaWVjZSBvZiB0aGUgcGF0aFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICovXG5cbmV4cG9ydHMuaGFzID0gZnVuY3Rpb24ocGF0aCwgbykge1xuICB2YXIgcGFydHMgPSB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgP1xuICAgIHN0cmluZ1RvUGFydHMocGF0aCkgOlxuICAgIHBhdGg7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnRzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYHBhdGhgLiBNdXN0IGJlIGVpdGhlciBzdHJpbmcgb3IgYXJyYXknKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBwYXJ0cy5sZW5ndGg7XG4gIHZhciBjdXIgPSBvO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJ0c1tpXSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHBhcnRzW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBzZWdtZW50IG9mIHBhdGggdG8gYGhhcygpYCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlciwgZ290ICcgKyB0eXBlb2YgcGFydHNbaV0pO1xuICAgIH1cbiAgICBpZiAoY3VyID09IG51bGwgfHwgdHlwZW9mIGN1ciAhPT0gJ29iamVjdCcgfHwgIShwYXJ0c1tpXSBpbiBjdXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGN1ciA9IGN1cltwYXJ0c1tpXV07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyB0aGUgbGFzdCBwaWVjZSBvZiBgcGF0aGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9cbiAqL1xuXG5leHBvcnRzLnVuc2V0ID0gZnVuY3Rpb24ocGF0aCwgbykge1xuICB2YXIgcGFydHMgPSB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgP1xuICAgIHN0cmluZ1RvUGFydHMocGF0aCkgOlxuICAgIHBhdGg7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnRzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYHBhdGhgLiBNdXN0IGJlIGVpdGhlciBzdHJpbmcgb3IgYXJyYXknKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBwYXJ0cy5sZW5ndGg7XG4gIHZhciBjdXIgPSBvO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGN1ciA9PSBudWxsIHx8IHR5cGVvZiBjdXIgIT09ICdvYmplY3QnIHx8ICEocGFydHNbaV0gaW4gY3VyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcnRzW2ldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcGFydHNbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIHNlZ21lbnQgb2YgcGF0aCB0byBgdW5zZXQoKWAgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXIsIGdvdCAnICsgdHlwZW9mIHBhcnRzW2ldKTtcbiAgICB9XG4gICAgLy8gRGlzYWxsb3cgYW55IHVwZGF0ZXMgdG8gX19wcm90b19fIG9yIHNwZWNpYWwgcHJvcGVydGllcy5cbiAgICBpZiAoaWdub3JlUHJvcGVydGllcy5pbmRleE9mKHBhcnRzW2ldKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxlbiAtIDEpIHtcbiAgICAgIGRlbGV0ZSBjdXJbcGFydHNbaV1dO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGN1ciA9IGN1ciBpbnN0YW5jZW9mIE1hcCA/IGN1ci5nZXQocGFydHNbaV0pIDogY3VyW3BhcnRzW2ldXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdmFsYCBhdCB0aGUgZ2l2ZW4gYHBhdGhgIG9mIG9iamVjdCBgb2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7QW55dGhpbmd9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9cbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3BlY2lhbF0gV2hlbiB0aGlzIHByb3BlcnR5IG5hbWUgaXMgcHJlc2VudCBvbiBhbnkgb2JqZWN0IGluIHRoZSBwYXRoLCB3YWxraW5nIHdpbGwgY29udGludWUgb24gdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbWFwXSBPcHRpb25hbCBmdW5jdGlvbiB3aGljaCBpcyBwYXNzZWQgZWFjaCBpbmRpdmlkdWFsIHZhbHVlIGJlZm9yZSBzZXR0aW5nIGl0LiBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSBgbWFwYCBpcyB1c2VkIGluIHRoZSBvcmlnaW5hbCB2YWx1ZXMgcGxhY2UuXG4gKi9cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbihwYXRoLCB2YWwsIG8sIHNwZWNpYWwsIG1hcCwgX2NvcHlpbmcpIHtcbiAgdmFyIGxvb2t1cDtcblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3BlY2lhbCkge1xuICAgIGlmIChzcGVjaWFsLmxlbmd0aCA8IDIpIHtcbiAgICAgIG1hcCA9IHNwZWNpYWw7XG4gICAgICBzcGVjaWFsID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb29rdXAgPSBzcGVjaWFsO1xuICAgICAgc3BlY2lhbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBtYXAgfHwgKG1hcCA9IEspO1xuXG4gIHZhciBwYXJ0cyA9ICdzdHJpbmcnID09IHR5cGVvZiBwYXRoXG4gICAgPyBzdHJpbmdUb1BhcnRzKHBhdGgpXG4gICAgOiBwYXRoO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJ0cykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGBwYXRoYC4gTXVzdCBiZSBlaXRoZXIgc3RyaW5nIG9yIGFycmF5Jyk7XG4gIH1cblxuICBpZiAobnVsbCA9PSBvKSByZXR1cm47XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2YgcGFydHNbaV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwYXJ0c1tpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggc2VnbWVudCBvZiBwYXRoIHRvIGBzZXQoKWAgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXIsIGdvdCAnICsgdHlwZW9mIHBhcnRzW2ldKTtcbiAgICB9XG4gICAgLy8gU2lsZW50bHkgaWdub3JlIGFueSB1cGRhdGVzIHRvIGBfX3Byb3RvX19gLCB0aGVzZSBhcmUgcG90ZW50aWFsbHlcbiAgICAvLyBkYW5nZXJvdXMgaWYgdXNpbmcgbXBhdGggd2l0aCB1bnNhbml0aXplZCBkYXRhLlxuICAgIGlmIChpZ25vcmVQcm9wZXJ0aWVzLmluZGV4T2YocGFydHNbaV0pICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBleGlzdGFuY2Ugb2YgJCBpbiBhIHBhdGggdGVsbHMgdXMgaWYgdGhlIHVzZXIgZGVzaXJlc1xuICAvLyB0aGUgY29weWluZyBvZiBhbiBhcnJheSBpbnN0ZWFkIG9mIHNldHRpbmcgZWFjaCB2YWx1ZSBvZlxuICAvLyB0aGUgYXJyYXkgdG8gdGhlIG9uZSBieSBvbmUgdG8gbWF0Y2hpbmcgcG9zaXRpb25zIG9mIHRoZVxuICAvLyBjdXJyZW50IGFycmF5LiBVbmxlc3MgdGhlIHVzZXIgZXhwbGljaXRseSBvcHRlZCBvdXQgYnkgcGFzc2luZ1xuICAvLyBmYWxzZSwgc2VlIEF1dG9tYXR0aWMvbW9uZ29vc2UjNjI3M1xuICB2YXIgY29weSA9IF9jb3B5aW5nIHx8ICgvXFwkLy50ZXN0KHBhdGgpICYmIF9jb3B5aW5nICE9PSBmYWxzZSksXG4gICAgICBvYmogPSBvLFxuICAgICAgcGFydDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoIC0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgaWYgKCckJyA9PSBwYXJ0KSB7XG4gICAgICBpZiAoaSA9PSBsZW4gLSAxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSAmJiAhL15cXGQrJC8udGVzdChwYXJ0KSkge1xuICAgICAgdmFyIHBhdGhzID0gcGFydHMuc2xpY2UoaSk7XG4gICAgICBpZiAoIWNvcHkgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqLmxlbmd0aCAmJiBqIDwgdmFsLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgLy8gYXNzaWdubWVudCBvZiBzaW5nbGUgdmFsdWVzIG9mIGFycmF5XG4gICAgICAgICAgZXhwb3J0cy5zZXQocGF0aHMsIHZhbFtqXSwgb2JqW2pdLCBzcGVjaWFsIHx8IGxvb2t1cCwgbWFwLCBjb3B5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAvLyBhc3NpZ25tZW50IG9mIGVudGlyZSB2YWx1ZVxuICAgICAgICAgIGV4cG9ydHMuc2V0KHBhdGhzLCB2YWwsIG9ialtqXSwgc3BlY2lhbCB8fCBsb29rdXAsIG1hcCwgY29weSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobG9va3VwKSB7XG4gICAgICBvYmogPSBsb29rdXAob2JqLCBwYXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF90byA9IHNwZWNpYWwgJiYgb2JqW3NwZWNpYWxdID8gb2JqW3NwZWNpYWxdIDogb2JqO1xuICAgICAgb2JqID0gX3RvIGluc3RhbmNlb2YgTWFwID9cbiAgICAgICAgX3RvLmdldChwYXJ0KSA6XG4gICAgICAgIF90b1twYXJ0XTtcbiAgICB9XG5cbiAgICBpZiAoIW9iaikgcmV0dXJuO1xuICB9XG5cbiAgLy8gcHJvY2VzcyB0aGUgbGFzdCBwcm9wZXJ0eSBvZiB0aGUgcGF0aFxuXG4gIHBhcnQgPSBwYXJ0c1tsZW5dO1xuXG4gIC8vIHVzZSB0aGUgc3BlY2lhbCBwcm9wZXJ0eSBpZiBleGlzdHNcbiAgaWYgKHNwZWNpYWwgJiYgb2JqW3NwZWNpYWxdKSB7XG4gICAgb2JqID0gb2JqW3NwZWNpYWxdO1xuICB9XG5cbiAgLy8gc2V0IHRoZSB2YWx1ZSBvbiB0aGUgbGFzdCBicmFuY2hcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSAmJiAhL15cXGQrJC8udGVzdChwYXJ0KSkge1xuICAgIGlmICghY29weSAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIF9zZXRBcnJheShvYmosIHZhbCwgcGFydCwgbG9va3VwLCBzcGVjaWFsLCBtYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgaXRlbSA9IG9ialtqXTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICBsb29rdXAoaXRlbSwgcGFydCwgbWFwKHZhbCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXRlbVtzcGVjaWFsXSkgaXRlbSA9IGl0ZW1bc3BlY2lhbF07XG4gICAgICAgICAgICBpdGVtW3BhcnRdID0gbWFwKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChsb29rdXApIHtcbiAgICAgIGxvb2t1cChvYmosIHBhcnQsIG1hcCh2YWwpKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgb2JqLnNldChwYXJ0LCBtYXAodmFsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtwYXJ0XSA9IG1hcCh2YWwpO1xuICAgIH1cbiAgfVxufTtcblxuLyohXG4gKiBTcGxpdCBhIHN0cmluZyBwYXRoIGludG8gY29tcG9uZW50cyBkZWxpbWl0ZWQgYnkgJy4nIG9yXG4gKiAnW1xcZCtdJ1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqICAgICBzdHJpbmdUb1BhcnRzKCdmb29bMF0uYmFyLjEnKTsgLy8gWydmb28nLCAnMCcsICdiYXInLCAnMSddXG4gKi9cblxuZXhwb3J0cy5zdHJpbmdUb1BhcnRzID0gc3RyaW5nVG9QYXJ0cztcblxuLyohXG4gKiBSZWN1cnNpdmVseSBzZXQgbmVzdGVkIGFycmF5c1xuICovXG5cbmZ1bmN0aW9uIF9zZXRBcnJheShvYmosIHZhbCwgcGFydCwgbG9va3VwLCBzcGVjaWFsLCBtYXApIHtcbiAgZm9yICh2YXIgaXRlbSwgaiA9IDA7IGogPCBvYmoubGVuZ3RoICYmIGogPCB2YWwubGVuZ3RoOyArK2opIHtcbiAgICBpdGVtID0gb2JqW2pdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pICYmIEFycmF5LmlzQXJyYXkodmFsW2pdKSkge1xuICAgICAgX3NldEFycmF5KGl0ZW0sIHZhbFtqXSwgcGFydCwgbG9va3VwLCBzcGVjaWFsLCBtYXApO1xuICAgIH0gZWxzZSBpZiAoaXRlbSkge1xuICAgICAgaWYgKGxvb2t1cCkge1xuICAgICAgICBsb29rdXAoaXRlbSwgcGFydCwgbWFwKHZhbFtqXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW1bc3BlY2lhbF0pIGl0ZW0gPSBpdGVtW3NwZWNpYWxdO1xuICAgICAgICBpdGVtW3BhcnRdID0gbWFwKHZhbFtqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogUmV0dXJucyB0aGUgdmFsdWUgcGFzc2VkIHRvIGl0LlxuICovXG5cbmZ1bmN0aW9uIEsodikge1xuICByZXR1cm4gdjtcbn1cbiJdLCJuYW1lcyI6WyJzdHJpbmdUb1BhcnRzIiwicmVxdWlyZSIsImlnbm9yZVByb3BlcnRpZXMiLCJleHBvcnRzIiwiZ2V0IiwicGF0aCIsIm8iLCJzcGVjaWFsIiwibWFwIiwibG9va3VwIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiSyIsInBhcnRzIiwiQXJyYXkiLCJpc0FycmF5IiwiVHlwZUVycm9yIiwib2JqIiwicGFydCIsImkiLCJ0ZXN0IiwicGF0aHMiLCJzbGljZSIsImNvbmNhdCIsIml0ZW0iLCJfZnJvbSIsIk1hcCIsImhhcyIsImxlbiIsImN1ciIsInVuc2V0IiwiaW5kZXhPZiIsInNldCIsInZhbCIsIl9jb3B5aW5nIiwiY29weSIsImoiLCJfdG8iLCJfc2V0QXJyYXkiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mpath/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mpath/lib/stringToParts.js":
/*!*************************************************!*\
  !*** ./node_modules/mpath/lib/stringToParts.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function stringToParts(str) {\n    const result = [];\n    let curPropertyName = \"\";\n    let state = \"DEFAULT\";\n    for(let i = 0; i < str.length; ++i){\n        // Fall back to treating as property name rather than bracket notation if\n        // square brackets contains something other than a number.\n        if (state === \"IN_SQUARE_BRACKETS\" && !/\\d/.test(str[i]) && str[i] !== \"]\") {\n            state = \"DEFAULT\";\n            curPropertyName = result[result.length - 1] + \"[\" + curPropertyName;\n            result.splice(result.length - 1, 1);\n        }\n        if (str[i] === \"[\") {\n            if (state !== \"IMMEDIATELY_AFTER_SQUARE_BRACKETS\") {\n                result.push(curPropertyName);\n                curPropertyName = \"\";\n            }\n            state = \"IN_SQUARE_BRACKETS\";\n        } else if (str[i] === \"]\") {\n            if (state === \"IN_SQUARE_BRACKETS\") {\n                state = \"IMMEDIATELY_AFTER_SQUARE_BRACKETS\";\n                result.push(curPropertyName);\n                curPropertyName = \"\";\n            } else {\n                state = \"DEFAULT\";\n                curPropertyName += str[i];\n            }\n        } else if (str[i] === \".\") {\n            if (state !== \"IMMEDIATELY_AFTER_SQUARE_BRACKETS\") {\n                result.push(curPropertyName);\n                curPropertyName = \"\";\n            }\n            state = \"DEFAULT\";\n        } else {\n            curPropertyName += str[i];\n        }\n    }\n    if (state !== \"IMMEDIATELY_AFTER_SQUARE_BRACKETS\") {\n        result.push(curPropertyName);\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXBhdGgvbGliL3N0cmluZ1RvUGFydHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGNBQWNDLEdBQUc7SUFDekMsTUFBTUMsU0FBUyxFQUFFO0lBRWpCLElBQUlDLGtCQUFrQjtJQUN0QixJQUFJQyxRQUFRO0lBQ1osSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLElBQUlLLE1BQU0sRUFBRSxFQUFFRCxFQUFHO1FBQ25DLHlFQUF5RTtRQUN6RSwwREFBMEQ7UUFDMUQsSUFBSUQsVUFBVSx3QkFBd0IsQ0FBQyxLQUFLRyxJQUFJLENBQUNOLEdBQUcsQ0FBQ0ksRUFBRSxLQUFLSixHQUFHLENBQUNJLEVBQUUsS0FBSyxLQUFLO1lBQzFFRCxRQUFRO1lBQ1JELGtCQUFrQkQsTUFBTSxDQUFDQSxPQUFPSSxNQUFNLEdBQUcsRUFBRSxHQUFHLE1BQU1IO1lBQ3BERCxPQUFPTSxNQUFNLENBQUNOLE9BQU9JLE1BQU0sR0FBRyxHQUFHO1FBQ25DO1FBRUEsSUFBSUwsR0FBRyxDQUFDSSxFQUFFLEtBQUssS0FBSztZQUNsQixJQUFJRCxVQUFVLHFDQUFxQztnQkFDakRGLE9BQU9PLElBQUksQ0FBQ047Z0JBQ1pBLGtCQUFrQjtZQUNwQjtZQUNBQyxRQUFRO1FBQ1YsT0FBTyxJQUFJSCxHQUFHLENBQUNJLEVBQUUsS0FBSyxLQUFLO1lBQ3pCLElBQUlELFVBQVUsc0JBQXNCO2dCQUNsQ0EsUUFBUTtnQkFDUkYsT0FBT08sSUFBSSxDQUFDTjtnQkFDWkEsa0JBQWtCO1lBQ3BCLE9BQU87Z0JBQ0xDLFFBQVE7Z0JBQ1JELG1CQUFtQkYsR0FBRyxDQUFDSSxFQUFFO1lBQzNCO1FBQ0YsT0FBTyxJQUFJSixHQUFHLENBQUNJLEVBQUUsS0FBSyxLQUFLO1lBQ3pCLElBQUlELFVBQVUscUNBQXFDO2dCQUNqREYsT0FBT08sSUFBSSxDQUFDTjtnQkFDWkEsa0JBQWtCO1lBQ3BCO1lBQ0FDLFFBQVE7UUFDVixPQUFPO1lBQ0xELG1CQUFtQkYsR0FBRyxDQUFDSSxFQUFFO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJRCxVQUFVLHFDQUFxQztRQUNqREYsT0FBT08sSUFBSSxDQUFDTjtJQUNkO0lBRUEsT0FBT0Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2FkbWluLy4vbm9kZV9tb2R1bGVzL21wYXRoL2xpYi9zdHJpbmdUb1BhcnRzLmpzP2JlODQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ1RvUGFydHMoc3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIGxldCBjdXJQcm9wZXJ0eU5hbWUgPSAnJztcbiAgbGV0IHN0YXRlID0gJ0RFRkFVTFQnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIEZhbGwgYmFjayB0byB0cmVhdGluZyBhcyBwcm9wZXJ0eSBuYW1lIHJhdGhlciB0aGFuIGJyYWNrZXQgbm90YXRpb24gaWZcbiAgICAvLyBzcXVhcmUgYnJhY2tldHMgY29udGFpbnMgc29tZXRoaW5nIG90aGVyIHRoYW4gYSBudW1iZXIuXG4gICAgaWYgKHN0YXRlID09PSAnSU5fU1FVQVJFX0JSQUNLRVRTJyAmJiAhL1xcZC8udGVzdChzdHJbaV0pICYmIHN0cltpXSAhPT0gJ10nKSB7XG4gICAgICBzdGF0ZSA9ICdERUZBVUxUJztcbiAgICAgIGN1clByb3BlcnR5TmFtZSA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gKyAnWycgKyBjdXJQcm9wZXJ0eU5hbWU7XG4gICAgICByZXN1bHQuc3BsaWNlKHJlc3VsdC5sZW5ndGggLSAxLCAxKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyW2ldID09PSAnWycpIHtcbiAgICAgIGlmIChzdGF0ZSAhPT0gJ0lNTUVESUFURUxZX0FGVEVSX1NRVUFSRV9CUkFDS0VUUycpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VyUHJvcGVydHlOYW1lKTtcbiAgICAgICAgY3VyUHJvcGVydHlOYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBzdGF0ZSA9ICdJTl9TUVVBUkVfQlJBQ0tFVFMnO1xuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSAnXScpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ0lOX1NRVUFSRV9CUkFDS0VUUycpIHtcbiAgICAgICAgc3RhdGUgPSAnSU1NRURJQVRFTFlfQUZURVJfU1FVQVJFX0JSQUNLRVRTJztcbiAgICAgICAgcmVzdWx0LnB1c2goY3VyUHJvcGVydHlOYW1lKTtcbiAgICAgICAgY3VyUHJvcGVydHlOYW1lID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9ICdERUZBVUxUJztcbiAgICAgICAgY3VyUHJvcGVydHlOYW1lICs9IHN0cltpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gJy4nKSB7XG4gICAgICBpZiAoc3RhdGUgIT09ICdJTU1FRElBVEVMWV9BRlRFUl9TUVVBUkVfQlJBQ0tFVFMnKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1clByb3BlcnR5TmFtZSk7XG4gICAgICAgIGN1clByb3BlcnR5TmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgc3RhdGUgPSAnREVGQVVMVCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1clByb3BlcnR5TmFtZSArPSBzdHJbaV07XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlICE9PSAnSU1NRURJQVRFTFlfQUZURVJfU1FVQVJFX0JSQUNLRVRTJykge1xuICAgIHJlc3VsdC5wdXNoKGN1clByb3BlcnR5TmFtZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTsiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInN0cmluZ1RvUGFydHMiLCJzdHIiLCJyZXN1bHQiLCJjdXJQcm9wZXJ0eU5hbWUiLCJzdGF0ZSIsImkiLCJsZW5ndGgiLCJ0ZXN0Iiwic3BsaWNlIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mpath/lib/stringToParts.js\n");

/***/ })

};
;