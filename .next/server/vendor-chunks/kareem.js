"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/kareem";
exports.ids = ["vendor-chunks/kareem"];
exports.modules = {

/***/ "(ssr)/./node_modules/kareem/index.js":
/*!**************************************!*\
  !*** ./node_modules/kareem/index.js ***!
  \**************************************/
/***/ ((module) => {

eval("\n/**\n * Create a new instance\n */ function Kareem() {\n    this._pres = new Map();\n    this._posts = new Map();\n}\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n    if (!(this instanceof Kareem.skipWrappedFunction)) {\n        return new Kareem.skipWrappedFunction(...arguments);\n    }\n    this.args = [\n        ...arguments\n    ];\n};\nKareem.overwriteResult = function overwriteResult() {\n    if (!(this instanceof Kareem.overwriteResult)) {\n        return new Kareem.overwriteResult(...arguments);\n    }\n    this.args = [\n        ...arguments\n    ];\n};\n/**\n * Execute all \"pre\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Optional arguments or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */ Kareem.prototype.execPre = function(name, context, args, callback) {\n    if (arguments.length === 3) {\n        callback = args;\n        args = [];\n    }\n    const pres = this._pres.get(name) || [];\n    const numPres = pres.length;\n    const numAsyncPres = pres.numAsync || 0;\n    let currentPre = 0;\n    let asyncPresLeft = numAsyncPres;\n    let done = false;\n    const $args = args;\n    let shouldSkipWrappedFunction = null;\n    if (!numPres) {\n        return nextTick(function() {\n            callback(null);\n        });\n    }\n    function next() {\n        if (currentPre >= numPres) {\n            return;\n        }\n        const pre = pres[currentPre];\n        if (pre.isAsync) {\n            const args = [\n                decorateNextFn(_next),\n                decorateNextFn(function(error) {\n                    if (error) {\n                        if (done) {\n                            return;\n                        }\n                        if (error instanceof Kareem.skipWrappedFunction) {\n                            shouldSkipWrappedFunction = error;\n                        } else {\n                            done = true;\n                            return callback(error);\n                        }\n                    }\n                    if (--asyncPresLeft === 0 && currentPre >= numPres) {\n                        return callback(shouldSkipWrappedFunction);\n                    }\n                })\n            ];\n            callMiddlewareFunction(pre.fn, context, args, args[0]);\n        } else if (pre.fn.length > 0) {\n            const args = [\n                decorateNextFn(_next)\n            ];\n            const _args = arguments.length >= 2 ? arguments : [\n                null\n            ].concat($args);\n            for(let i = 1; i < _args.length; ++i){\n                if (i === _args.length - 1 && typeof _args[i] === \"function\") {\n                    continue; // skip callbacks to avoid accidentally calling the callback from a hook\n                }\n                args.push(_args[i]);\n            }\n            callMiddlewareFunction(pre.fn, context, args, args[0]);\n        } else {\n            let maybePromiseLike = null;\n            try {\n                maybePromiseLike = pre.fn.call(context);\n            } catch (err) {\n                if (err != null) {\n                    return callback(err);\n                }\n            }\n            if (isPromiseLike(maybePromiseLike)) {\n                maybePromiseLike.then(()=>_next(), (err)=>_next(err));\n            } else {\n                if (++currentPre >= numPres) {\n                    if (asyncPresLeft > 0) {\n                        // Leave parallel hooks to run\n                        return;\n                    } else {\n                        return nextTick(function() {\n                            callback(shouldSkipWrappedFunction);\n                        });\n                    }\n                }\n                next();\n            }\n        }\n    }\n    next.apply(null, [\n        null\n    ].concat(args));\n    function _next(error) {\n        if (error) {\n            if (done) {\n                return;\n            }\n            if (error instanceof Kareem.skipWrappedFunction) {\n                shouldSkipWrappedFunction = error;\n            } else {\n                done = true;\n                return callback(error);\n            }\n        }\n        if (++currentPre >= numPres) {\n            if (asyncPresLeft > 0) {\n                // Leave parallel hooks to run\n                return;\n            } else {\n                return callback(shouldSkipWrappedFunction);\n            }\n        }\n        next.apply(context, arguments);\n    }\n};\n/**\n * Execute all \"pre\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} [args] Apply custom arguments to the hook\n * @returns {void}\n */ Kareem.prototype.execPreSync = function(name, context, args) {\n    const pres = this._pres.get(name) || [];\n    const numPres = pres.length;\n    for(let i = 0; i < numPres; ++i){\n        pres[i].fn.apply(context, args || []);\n    }\n};\n/**\n * Execute all \"post\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @param {*} options Optional options or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */ Kareem.prototype.execPost = function(name, context, args, options, callback) {\n    if (arguments.length < 5) {\n        callback = options;\n        options = null;\n    }\n    const posts = this._posts.get(name) || [];\n    const numPosts = posts.length;\n    let currentPost = 0;\n    let firstError = null;\n    if (options && options.error) {\n        firstError = options.error;\n    }\n    if (!numPosts) {\n        return nextTick(function() {\n            callback.apply(null, [\n                firstError\n            ].concat(args));\n        });\n    }\n    function next() {\n        const post = posts[currentPost].fn;\n        let numArgs = 0;\n        const argLength = args.length;\n        const newArgs = [];\n        for(let i = 0; i < argLength; ++i){\n            numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;\n            if (!args[i] || !args[i]._kareemIgnore) {\n                newArgs.push(args[i]);\n            }\n        }\n        if (firstError) {\n            if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n                const _cb = decorateNextFn(function(error) {\n                    if (error) {\n                        if (error instanceof Kareem.overwriteResult) {\n                            args = error.args;\n                            if (++currentPost >= numPosts) {\n                                return callback.call(null, firstError);\n                            }\n                            return next();\n                        }\n                        firstError = error;\n                    }\n                    if (++currentPost >= numPosts) {\n                        return callback.call(null, firstError);\n                    }\n                    next();\n                });\n                callMiddlewareFunction(post, context, [\n                    firstError\n                ].concat(newArgs).concat([\n                    _cb\n                ]), _cb);\n            } else {\n                if (++currentPost >= numPosts) {\n                    return callback.call(null, firstError);\n                }\n                next();\n            }\n        } else {\n            const _cb = decorateNextFn(function(error) {\n                if (error) {\n                    if (error instanceof Kareem.overwriteResult) {\n                        args = error.args;\n                        if (++currentPost >= numPosts) {\n                            return callback.apply(null, [\n                                null\n                            ].concat(args));\n                        }\n                        return next();\n                    }\n                    firstError = error;\n                    return next();\n                }\n                if (++currentPost >= numPosts) {\n                    return callback.apply(null, [\n                        null\n                    ].concat(args));\n                }\n                next();\n            });\n            if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n                // Skip error handlers if no error\n                if (++currentPost >= numPosts) {\n                    return callback.apply(null, [\n                        null\n                    ].concat(args));\n                }\n                return next();\n            }\n            if (post.length === numArgs + 1) {\n                callMiddlewareFunction(post, context, newArgs.concat([\n                    _cb\n                ]), _cb);\n            } else {\n                let error;\n                let maybePromiseLike;\n                try {\n                    maybePromiseLike = post.apply(context, newArgs);\n                } catch (err) {\n                    error = err;\n                    firstError = err;\n                }\n                if (isPromiseLike(maybePromiseLike)) {\n                    return maybePromiseLike.then((res)=>{\n                        _cb(res instanceof Kareem.overwriteResult ? res : null);\n                    }, (err)=>_cb(err));\n                }\n                if (maybePromiseLike instanceof Kareem.overwriteResult) {\n                    args = maybePromiseLike.args;\n                }\n                if (++currentPost >= numPosts) {\n                    return callback.apply(null, [\n                        error\n                    ].concat(args));\n                }\n                next();\n            }\n        }\n    }\n    next();\n};\n/**\n * Execute all \"post\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @returns {Array} The used arguments\n */ Kareem.prototype.execPostSync = function(name, context, args) {\n    const posts = this._posts.get(name) || [];\n    const numPosts = posts.length;\n    for(let i = 0; i < numPosts; ++i){\n        const res = posts[i].fn.apply(context, args || []);\n        if (res instanceof Kareem.overwriteResult) {\n            args = res.args;\n        }\n    }\n    return args;\n};\n/**\n * Create a synchronous wrapper for \"fn\"\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @returns {Function} The wrapped function\n */ Kareem.prototype.createWrapperSync = function(name, fn) {\n    const _this = this;\n    return function syncWrapper() {\n        _this.execPreSync(name, this, arguments);\n        const toReturn = fn.apply(this, arguments);\n        const result = _this.execPostSync(name, this, [\n            toReturn\n        ]);\n        return result[0];\n    };\n};\nfunction _handleWrapError(instance, error, name, context, args, options, callback) {\n    if (options.useErrorHandlers) {\n        return instance.execPost(name, context, args, {\n            error: error\n        }, function(error) {\n            return typeof callback === \"function\" && callback(error);\n        });\n    } else {\n        return typeof callback === \"function\" && callback(error);\n    }\n}\n/**\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\n * @param {String} name The name of the hook\n * @param {Function} fn The function for the hook\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} [options]\n * @param {Boolean} [options.checkForPromise]\n * @returns {void}\n */ Kareem.prototype.wrap = function(name, fn, context, args, options) {\n    const lastArg = args.length > 0 ? args[args.length - 1] : null;\n    const argsWithoutCb = Array.from(args);\n    typeof lastArg === \"function\" && argsWithoutCb.pop();\n    const _this = this;\n    options = options || {};\n    const checkForPromise = options.checkForPromise;\n    this.execPre(name, context, args, function(error) {\n        if (error && !(error instanceof Kareem.skipWrappedFunction)) {\n            const numCallbackParams = options.numCallbackParams || 0;\n            const errorArgs = options.contextParameter ? [\n                context\n            ] : [];\n            for(let i = errorArgs.length; i < numCallbackParams; ++i){\n                errorArgs.push(null);\n            }\n            return _handleWrapError(_this, error, name, context, errorArgs, options, lastArg);\n        }\n        const numParameters = fn.length;\n        let ret;\n        if (error instanceof Kareem.skipWrappedFunction) {\n            ret = error.args[0];\n            return _cb(null, ...error.args);\n        } else {\n            try {\n                ret = fn.apply(context, argsWithoutCb.concat(_cb));\n            } catch (err) {\n                return _cb(err);\n            }\n        }\n        if (checkForPromise) {\n            if (isPromiseLike(ret)) {\n                // Thenable, use it\n                return ret.then((res)=>_cb(null, res), (err)=>_cb(err));\n            }\n            // If `fn()` doesn't have a callback argument and doesn't return a\n            // promise, assume it is sync\n            if (numParameters < argsWithoutCb.length + 1) {\n                return _cb(null, ret);\n            }\n        }\n        function _cb() {\n            const argsWithoutError = Array.from(arguments);\n            argsWithoutError.shift();\n            if (options.nullResultByDefault && argsWithoutError.length === 0) {\n                argsWithoutError.push(null);\n            }\n            if (arguments[0]) {\n                // Assume error\n                return _handleWrapError(_this, arguments[0], name, context, argsWithoutError, options, lastArg);\n            } else {\n                _this.execPost(name, context, argsWithoutError, function() {\n                    if (lastArg === null) {\n                        return;\n                    }\n                    arguments[0] ? lastArg(arguments[0]) : lastArg.apply(context, arguments);\n                });\n            }\n        }\n    });\n};\n/**\n * Filter current instance for something specific and return the filtered clone\n * @param {Function} fn The filter function\n * @returns {Kareem} The cloned and filtered instance\n */ Kareem.prototype.filter = function(fn) {\n    const clone = this.clone();\n    const pres = Array.from(clone._pres.keys());\n    for (const name of pres){\n        const hooks = this._pres.get(name).map((h)=>Object.assign({}, h, {\n                name: name\n            })).filter(fn);\n        if (hooks.length === 0) {\n            clone._pres.delete(name);\n            continue;\n        }\n        hooks.numAsync = hooks.filter((h)=>h.isAsync).length;\n        clone._pres.set(name, hooks);\n    }\n    const posts = Array.from(clone._posts.keys());\n    for (const name of posts){\n        const hooks = this._posts.get(name).map((h)=>Object.assign({}, h, {\n                name: name\n            })).filter(fn);\n        if (hooks.length === 0) {\n            clone._posts.delete(name);\n            continue;\n        }\n        clone._posts.set(name, hooks);\n    }\n    return clone;\n};\n/**\n * Check for a \"name\" to exist either in pre or post hooks\n * @param {String} name The name of the hook\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\n */ Kareem.prototype.hasHooks = function(name) {\n    return this._pres.has(name) || this._posts.has(name);\n};\n/**\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Object} [options]\n * @returns {Function} The wrapped function\n */ Kareem.prototype.createWrapper = function(name, fn, context, options) {\n    const _this = this;\n    if (!this.hasHooks(name)) {\n        // Fast path: if there's no hooks for this function, just return the\n        // function wrapped in a nextTick()\n        return function() {\n            nextTick(()=>fn.apply(this, arguments));\n        };\n    }\n    return function() {\n        const _context = context || this;\n        _this.wrap(name, fn, _context, Array.from(arguments), options);\n    };\n};\n/**\n * Register a new hook for \"pre\"\n * @param {String} name The name of the hook\n * @param {Boolean} [isAsync]\n * @param {Function} fn The function to register for \"name\"\n * @param {never} error Unused\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */ Kareem.prototype.pre = function(name, isAsync, fn, error, unshift) {\n    let options = {};\n    if (typeof isAsync === \"object\" && isAsync !== null) {\n        options = isAsync;\n        isAsync = options.isAsync;\n    } else if (typeof arguments[1] !== \"boolean\") {\n        fn = isAsync;\n        isAsync = false;\n    }\n    const pres = this._pres.get(name) || [];\n    this._pres.set(name, pres);\n    if (isAsync) {\n        pres.numAsync = pres.numAsync || 0;\n        ++pres.numAsync;\n    }\n    if (typeof fn !== \"function\") {\n        throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n    }\n    if (unshift) {\n        pres.unshift(Object.assign({}, options, {\n            fn: fn,\n            isAsync: isAsync\n        }));\n    } else {\n        pres.push(Object.assign({}, options, {\n            fn: fn,\n            isAsync: isAsync\n        }));\n    }\n    return this;\n};\n/**\n * Register a new hook for \"post\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */ Kareem.prototype.post = function(name, options, fn, unshift) {\n    const posts = this._posts.get(name) || [];\n    if (typeof options === \"function\") {\n        unshift = !!fn;\n        fn = options;\n        options = {};\n    }\n    if (typeof fn !== \"function\") {\n        throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n    }\n    if (unshift) {\n        posts.unshift(Object.assign({}, options, {\n            fn: fn\n        }));\n    } else {\n        posts.push(Object.assign({}, options, {\n            fn: fn\n        }));\n    }\n    this._posts.set(name, posts);\n    return this;\n};\n/**\n * Clone the current instance\n * @returns {Kareem} The cloned instance\n */ Kareem.prototype.clone = function() {\n    const n = new Kareem();\n    for (const key of this._pres.keys()){\n        const clone = this._pres.get(key).slice();\n        clone.numAsync = this._pres.get(key).numAsync;\n        n._pres.set(key, clone);\n    }\n    for (const key of this._posts.keys()){\n        n._posts.set(key, this._posts.get(key).slice());\n    }\n    return n;\n};\n/**\n * Merge \"other\" into self or \"clone\"\n * @param {Kareem} other The instance to merge with\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\n * @returns {Kareem} The merged instance\n */ Kareem.prototype.merge = function(other, clone) {\n    clone = arguments.length === 1 ? true : clone;\n    const ret = clone ? this.clone() : this;\n    for (const key of other._pres.keys()){\n        const sourcePres = ret._pres.get(key) || [];\n        const deduplicated = other._pres.get(key).// Deduplicate based on `fn`\n        filter((p)=>sourcePres.map((_p)=>_p.fn).indexOf(p.fn) === -1);\n        const combined = sourcePres.concat(deduplicated);\n        combined.numAsync = sourcePres.numAsync || 0;\n        combined.numAsync += deduplicated.filter((p)=>p.isAsync).length;\n        ret._pres.set(key, combined);\n    }\n    for (const key of other._posts.keys()){\n        const sourcePosts = ret._posts.get(key) || [];\n        const deduplicated = other._posts.get(key).filter((p)=>sourcePosts.indexOf(p) === -1);\n        ret._posts.set(key, sourcePosts.concat(deduplicated));\n    }\n    return ret;\n};\nfunction callMiddlewareFunction(fn, context, args, next) {\n    let maybePromiseLike;\n    try {\n        maybePromiseLike = fn.apply(context, args);\n    } catch (error) {\n        return next(error);\n    }\n    if (isPromiseLike(maybePromiseLike)) {\n        maybePromiseLike.then(()=>next(), (err)=>next(err));\n    }\n}\nfunction isPromiseLike(v) {\n    return typeof v === \"object\" && v !== null && typeof v.then === \"function\";\n}\nfunction decorateNextFn(fn) {\n    let called = false;\n    const _this = this;\n    return function() {\n        // Ensure this function can only be called once\n        if (called) {\n            return;\n        }\n        called = true;\n        // Make sure to clear the stack so try/catch doesn't catch errors\n        // in subsequent middleware\n        return nextTick(()=>fn.apply(_this, arguments));\n    };\n}\nconst nextTick = typeof process === \"object\" && process !== null && process.nextTick || function nextTick(cb) {\n    setTimeout(cb, 0);\n};\nfunction isErrorHandlingMiddleware(post, numArgs) {\n    if (post.errorHandler) {\n        return true;\n    }\n    return post.fn.length === numArgs + 2;\n}\nmodule.exports = Kareem;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUUsRUFBRXJCLE9BQU8sRUFBRUwsSUFBSSxFQUFFbUIsSUFBSTtJQUNyRCxJQUFJWTtJQUNKLElBQUk7UUFDRkEsbUJBQW1CTCxHQUFHVSxLQUFLLENBQUMvQixTQUFTTDtJQUN2QyxFQUFFLE9BQU93QixPQUFPO1FBQ2QsT0FBT0wsS0FBS0s7SUFDZDtJQUVBLElBQUlVLGNBQWNILG1CQUFtQjtRQUNuQ0EsaUJBQWlCSSxJQUFJLENBQUMsSUFBTWhCLFFBQVFjLENBQUFBLE1BQU9kLEtBQUtjO0lBQ2xEO0FBQ0Y7QUFFQSxTQUFTQyxjQUFjc0UsQ0FBQztJQUN0QixPQUFRLE9BQU9BLE1BQU0sWUFBWUEsTUFBTSxRQUFRLE9BQU9BLEVBQUVyRSxJQUFJLEtBQUs7QUFDbkU7QUFFQSxTQUFTYixlQUFlSSxFQUFFO0lBQ3hCLElBQUkrRSxTQUFTO0lBQ2IsTUFBTW5ELFFBQVEsSUFBSTtJQUNsQixPQUFPO1FBQ0wsK0NBQStDO1FBQy9DLElBQUltRCxRQUFRO1lBQ1Y7UUFDRjtRQUNBQSxTQUFTO1FBQ1QsaUVBQWlFO1FBQ2pFLDJCQUEyQjtRQUMzQixPQUFPdkYsU0FBUyxJQUFNUSxHQUFHVSxLQUFLLENBQUNrQixPQUFPdkQ7SUFDeEM7QUFDRjtBQUVBLE1BQU1tQixXQUFXLE9BQU93RixZQUFZLFlBQVlBLFlBQVksUUFBUUEsUUFBUXhGLFFBQVEsSUFBSSxTQUFTQSxTQUFTeUYsRUFBRTtJQUMxR0MsV0FBV0QsSUFBSTtBQUNqQjtBQUVBLFNBQVMxRCwwQkFBMEJMLElBQUksRUFBRUMsT0FBTztJQUM5QyxJQUFJRCxLQUFLaUUsWUFBWSxFQUFFO1FBQ3JCLE9BQU87SUFDVDtJQUNBLE9BQU9qRSxLQUFLbEIsRUFBRSxDQUFDbkIsTUFBTSxLQUFLc0MsVUFBVTtBQUN0QztBQUVBaUUsT0FBT0MsT0FBTyxHQUFHckgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZG1pbi8uL25vZGVfbW9kdWxlcy9rYXJlZW0vaW5kZXguanM/ZGY0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEthcmVlbSgpIHtcbiAgdGhpcy5fcHJlcyA9IG5ldyBNYXAoKTtcbiAgdGhpcy5fcG9zdHMgPSBuZXcgTWFwKCk7XG59XG5cbkthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uID0gZnVuY3Rpb24gc2tpcFdyYXBwZWRGdW5jdGlvbigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSkge1xuICAgIHJldHVybiBuZXcgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24oLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIHRoaXMuYXJncyA9IFsuLi5hcmd1bWVudHNdO1xufTtcblxuS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCA9IGZ1bmN0aW9uIG92ZXJ3cml0ZVJlc3VsdCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQpKSB7XG4gICAgcmV0dXJuIG5ldyBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0KC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICB0aGlzLmFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhbGwgXCJwcmVcIiBob29rcyBmb3IgXCJuYW1lXCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBob29rIG5hbWUgdG8gZXhlY3V0ZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IE92ZXJ3cml0ZSB0aGUgXCJ0aGlzXCIgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBhcmdzIE9wdGlvbmFsIGFyZ3VtZW50cyBvciBkaXJlY3RseSB0aGUgY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBleGVjdXRpbmcgYWxsIGhvb2tzIGFyZSBmaW5pc2hlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkthcmVlbS5wcm90b3R5cGUuZXhlY1ByZSA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRleHQsIGFyZ3MsIGNhbGxiYWNrKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgY2FsbGJhY2sgPSBhcmdzO1xuICAgIGFyZ3MgPSBbXTtcbiAgfVxuICBjb25zdCBwcmVzID0gdGhpcy5fcHJlcy5nZXQobmFtZSkgfHwgW107XG4gIGNvbnN0IG51bVByZXMgPSBwcmVzLmxlbmd0aDtcbiAgY29uc3QgbnVtQXN5bmNQcmVzID0gcHJlcy5udW1Bc3luYyB8fCAwO1xuICBsZXQgY3VycmVudFByZSA9IDA7XG4gIGxldCBhc3luY1ByZXNMZWZ0ID0gbnVtQXN5bmNQcmVzO1xuICBsZXQgZG9uZSA9IGZhbHNlO1xuICBjb25zdCAkYXJncyA9IGFyZ3M7XG4gIGxldCBzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uID0gbnVsbDtcblxuICBpZiAoIW51bVByZXMpIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGN1cnJlbnRQcmUgPj0gbnVtUHJlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmUgPSBwcmVzW2N1cnJlbnRQcmVdO1xuXG4gICAgaWYgKHByZS5pc0FzeW5jKSB7XG4gICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICBkZWNvcmF0ZU5leHRGbihfbmV4dCksXG4gICAgICAgIGRlY29yYXRlTmV4dEZuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgICAgICAgICBzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uID0gZXJyb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKC0tYXN5bmNQcmVzTGVmdCA9PT0gMCAmJiBjdXJyZW50UHJlID49IG51bVByZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBdO1xuXG4gICAgICBjYWxsTWlkZGxld2FyZUZ1bmN0aW9uKHByZS5mbiwgY29udGV4dCwgYXJncywgYXJnc1swXSk7XG4gICAgfSBlbHNlIGlmIChwcmUuZm4ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYXJncyA9IFtkZWNvcmF0ZU5leHRGbihfbmV4dCldO1xuICAgICAgY29uc3QgX2FyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHMgOiBbbnVsbF0uY29uY2F0KCRhcmdzKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT09IF9hcmdzLmxlbmd0aCAtIDEgJiYgdHlwZW9mIF9hcmdzW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29udGludWU7IC8vIHNraXAgY2FsbGJhY2tzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBjYWxsaW5nIHRoZSBjYWxsYmFjayBmcm9tIGEgaG9va1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChfYXJnc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxNaWRkbGV3YXJlRnVuY3Rpb24ocHJlLmZuLCBjb250ZXh0LCBhcmdzLCBhcmdzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1heWJlUHJvbWlzZUxpa2UgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWF5YmVQcm9taXNlTGlrZSA9IHByZS5mbi5jYWxsKGNvbnRleHQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1Byb21pc2VMaWtlKG1heWJlUHJvbWlzZUxpa2UpKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZUxpa2UudGhlbigoKSA9PiBfbmV4dCgpLCBlcnIgPT4gX25leHQoZXJyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKytjdXJyZW50UHJlID49IG51bVByZXMpIHtcbiAgICAgICAgICBpZiAoYXN5bmNQcmVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgIC8vIExlYXZlIHBhcmFsbGVsIGhvb2tzIHRvIHJ1blxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHNob3VsZFNraXBXcmFwcGVkRnVuY3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0LmFwcGx5KG51bGwsIFtudWxsXS5jb25jYXQoYXJncykpO1xuXG4gIGZ1bmN0aW9uIF9uZXh0KGVycm9yKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgICBzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKytjdXJyZW50UHJlID49IG51bVByZXMpIHtcbiAgICAgIGlmIChhc3luY1ByZXNMZWZ0ID4gMCkge1xuICAgICAgICAvLyBMZWF2ZSBwYXJhbGxlbCBob29rcyB0byBydW5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHNob3VsZFNraXBXcmFwcGVkRnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5leHQuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFsbCBcInByZVwiIGhvb2tzIGZvciBcIm5hbWVcIiBzeW5jaHJvbm91c2x5XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaG9vayBuYW1lIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPdmVyd3JpdGUgdGhlIFwidGhpc1wiIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIEFwcGx5IGN1c3RvbSBhcmd1bWVudHMgdG8gdGhlIGhvb2tcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5LYXJlZW0ucHJvdG90eXBlLmV4ZWNQcmVTeW5jID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgYXJncykge1xuICBjb25zdCBwcmVzID0gdGhpcy5fcHJlcy5nZXQobmFtZSkgfHwgW107XG4gIGNvbnN0IG51bVByZXMgPSBwcmVzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVByZXM7ICsraSkge1xuICAgIHByZXNbaV0uZm4uYXBwbHkoY29udGV4dCwgYXJncyB8fCBbXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhbGwgXCJwb3N0XCIgaG9va3MgZm9yIFwibmFtZVwiXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaG9vayBuYW1lIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPdmVyd3JpdGUgdGhlIFwidGhpc1wiIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gYXJncyBBcHBseSBjdXN0b20gYXJndW1lbnRzIHRvIHRoZSBob29rXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBvciBkaXJlY3RseSB0aGUgY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBleGVjdXRpbmcgYWxsIGhvb2tzIGFyZSBmaW5pc2hlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkthcmVlbS5wcm90b3R5cGUuZXhlY1Bvc3QgPSBmdW5jdGlvbihuYW1lLCBjb250ZXh0LCBhcmdzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDUpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgY29uc3QgcG9zdHMgPSB0aGlzLl9wb3N0cy5nZXQobmFtZSkgfHwgW107XG4gIGNvbnN0IG51bVBvc3RzID0gcG9zdHMubGVuZ3RoO1xuICBsZXQgY3VycmVudFBvc3QgPSAwO1xuXG4gIGxldCBmaXJzdEVycm9yID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lcnJvcikge1xuICAgIGZpcnN0RXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICB9XG5cbiAgaWYgKCFudW1Qb3N0cykge1xuICAgIHJldHVybiBuZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtmaXJzdEVycm9yXS5jb25jYXQoYXJncykpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBjb25zdCBwb3N0ID0gcG9zdHNbY3VycmVudFBvc3RdLmZuO1xuICAgIGxldCBudW1BcmdzID0gMDtcbiAgICBjb25zdCBhcmdMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICBjb25zdCBuZXdBcmdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdMZW5ndGg7ICsraSkge1xuICAgICAgbnVtQXJncyArPSBhcmdzW2ldICYmIGFyZ3NbaV0uX2thcmVlbUlnbm9yZSA/IDAgOiAxO1xuICAgICAgaWYgKCFhcmdzW2ldIHx8ICFhcmdzW2ldLl9rYXJlZW1JZ25vcmUpIHtcbiAgICAgICAgbmV3QXJncy5wdXNoKGFyZ3NbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaXJzdEVycm9yKSB7XG4gICAgICBpZiAoaXNFcnJvckhhbmRsaW5nTWlkZGxld2FyZShwb3N0c1tjdXJyZW50UG9zdF0sIG51bUFyZ3MpKSB7XG4gICAgICAgIGNvbnN0IF9jYiA9IGRlY29yYXRlTmV4dEZuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBlcnJvci5hcmdzO1xuICAgICAgICAgICAgICBpZiAoKytjdXJyZW50UG9zdCA+PSBudW1Qb3N0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKG51bGwsIGZpcnN0RXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2N1cnJlbnRQb3N0ID49IG51bVBvc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChudWxsLCBmaXJzdEVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjYWxsTWlkZGxld2FyZUZ1bmN0aW9uKHBvc3QsIGNvbnRleHQsXG4gICAgICAgICAgW2ZpcnN0RXJyb3JdLmNvbmNhdChuZXdBcmdzKS5jb25jYXQoW19jYl0pLCBfY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChudWxsLCBmaXJzdEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IF9jYiA9IGRlY29yYXRlTmV4dEZuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBlcnJvci5hcmdzO1xuICAgICAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtudWxsXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlyc3RFcnJvciA9IGVycm9yO1xuICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKytjdXJyZW50UG9zdCA+PSBudW1Qb3N0cykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNFcnJvckhhbmRsaW5nTWlkZGxld2FyZShwb3N0c1tjdXJyZW50UG9zdF0sIG51bUFyZ3MpKSB7XG4gICAgICAgIC8vIFNraXAgZXJyb3IgaGFuZGxlcnMgaWYgbm8gZXJyb3JcbiAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0Lmxlbmd0aCA9PT0gbnVtQXJncyArIDEpIHtcbiAgICAgICAgY2FsbE1pZGRsZXdhcmVGdW5jdGlvbihwb3N0LCBjb250ZXh0LCBuZXdBcmdzLmNvbmNhdChbX2NiXSksIF9jYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCBtYXliZVByb21pc2VMaWtlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1heWJlUHJvbWlzZUxpa2UgPSBwb3N0LmFwcGx5KGNvbnRleHQsIG5ld0FyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UobWF5YmVQcm9taXNlTGlrZSkpIHtcbiAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlTGlrZS50aGVuKFxuICAgICAgICAgICAgKHJlcykgPT4ge1xuICAgICAgICAgICAgICBfY2IocmVzIGluc3RhbmNlb2YgS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCA/IHJlcyA6IG51bGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVyciA9PiBfY2IoZXJyKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF5YmVQcm9taXNlTGlrZSBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQpIHtcbiAgICAgICAgICBhcmdzID0gbWF5YmVQcm9taXNlTGlrZS5hcmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgW2Vycm9yXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhbGwgXCJwb3N0XCIgaG9va3MgZm9yIFwibmFtZVwiIHN5bmNocm9ub3VzbHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBob29rIG5hbWUgdG8gZXhlY3V0ZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IE92ZXJ3cml0ZSB0aGUgXCJ0aGlzXCIgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBhcmdzIEFwcGx5IGN1c3RvbSBhcmd1bWVudHMgdG8gdGhlIGhvb2tcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHVzZWQgYXJndW1lbnRzXG4gKi9cbkthcmVlbS5wcm90b3R5cGUuZXhlY1Bvc3RTeW5jID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgYXJncykge1xuICBjb25zdCBwb3N0cyA9IHRoaXMuX3Bvc3RzLmdldChuYW1lKSB8fCBbXTtcbiAgY29uc3QgbnVtUG9zdHMgPSBwb3N0cy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb3N0czsgKytpKSB7XG4gICAgY29uc3QgcmVzID0gcG9zdHNbaV0uZm4uYXBwbHkoY29udGV4dCwgYXJncyB8fCBbXSk7XG4gICAgaWYgKHJlcyBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQpIHtcbiAgICAgIGFyZ3MgPSByZXMuYXJncztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJncztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc3luY2hyb25vdXMgd3JhcHBlciBmb3IgXCJmblwiXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5jcmVhdGVXcmFwcGVyU3luYyA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uIHN5bmNXcmFwcGVyKCkge1xuICAgIF90aGlzLmV4ZWNQcmVTeW5jKG5hbWUsIHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBjb25zdCB0b1JldHVybiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBfdGhpcy5leGVjUG9zdFN5bmMobmFtZSwgdGhpcywgW3RvUmV0dXJuXSk7XG5cbiAgICByZXR1cm4gcmVzdWx0WzBdO1xuICB9O1xufTtcblxuZnVuY3Rpb24gX2hhbmRsZVdyYXBFcnJvcihpbnN0YW5jZSwgZXJyb3IsIG5hbWUsIGNvbnRleHQsIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChvcHRpb25zLnVzZUVycm9ySGFuZGxlcnMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuZXhlY1Bvc3QobmFtZSwgY29udGV4dCwgYXJncywgeyBlcnJvcjogZXJyb3IgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2soZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgcHJlIGhvb2tzLCBmb2xsb3dlZCBieSB0aGUgd3JhcHBlZCBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgcG9zdCBob29rcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gZm9yIHRoZSBob29rXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT3ZlcndyaXRlIHRoZSBcInRoaXNcIiBmb3IgdGhlIGhvb2tcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXBwbHkgY3VzdG9tIGFyZ3VtZW50cyB0byB0aGUgaG9va1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jaGVja0ZvclByb21pc2VdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24obmFtZSwgZm4sIGNvbnRleHQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgbGFzdEFyZyA9IChhcmdzLmxlbmd0aCA+IDAgPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiBudWxsKTtcbiAgY29uc3QgYXJnc1dpdGhvdXRDYiA9IEFycmF5LmZyb20oYXJncyk7XG4gIHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nICYmIGFyZ3NXaXRob3V0Q2IucG9wKCk7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgY2hlY2tGb3JQcm9taXNlID0gb3B0aW9ucy5jaGVja0ZvclByb21pc2U7XG5cbiAgdGhpcy5leGVjUHJlKG5hbWUsIGNvbnRleHQsIGFyZ3MsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikpIHtcbiAgICAgIGNvbnN0IG51bUNhbGxiYWNrUGFyYW1zID0gb3B0aW9ucy5udW1DYWxsYmFja1BhcmFtcyB8fCAwO1xuICAgICAgY29uc3QgZXJyb3JBcmdzID0gb3B0aW9ucy5jb250ZXh0UGFyYW1ldGVyID8gW2NvbnRleHRdIDogW107XG4gICAgICBmb3IgKGxldCBpID0gZXJyb3JBcmdzLmxlbmd0aDsgaSA8IG51bUNhbGxiYWNrUGFyYW1zOyArK2kpIHtcbiAgICAgICAgZXJyb3JBcmdzLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2hhbmRsZVdyYXBFcnJvcihfdGhpcywgZXJyb3IsIG5hbWUsIGNvbnRleHQsIGVycm9yQXJncyxcbiAgICAgICAgb3B0aW9ucywgbGFzdEFyZyk7XG4gICAgfVxuXG4gICAgY29uc3QgbnVtUGFyYW1ldGVycyA9IGZuLmxlbmd0aDtcbiAgICBsZXQgcmV0O1xuXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pIHtcbiAgICAgIHJldCA9IGVycm9yLmFyZ3NbMF07XG4gICAgICByZXR1cm4gX2NiKG51bGwsIC4uLmVycm9yLmFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBmbi5hcHBseShjb250ZXh0LCBhcmdzV2l0aG91dENiLmNvbmNhdChfY2IpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gX2NiKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrRm9yUHJvbWlzZSkge1xuICAgICAgaWYgKGlzUHJvbWlzZUxpa2UocmV0KSkge1xuICAgICAgICAvLyBUaGVuYWJsZSwgdXNlIGl0XG4gICAgICAgIHJldHVybiByZXQudGhlbihcbiAgICAgICAgICByZXMgPT4gX2NiKG51bGwsIHJlcyksXG4gICAgICAgICAgZXJyID0+IF9jYihlcnIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGBmbigpYCBkb2Vzbid0IGhhdmUgYSBjYWxsYmFjayBhcmd1bWVudCBhbmQgZG9lc24ndCByZXR1cm4gYVxuICAgICAgLy8gcHJvbWlzZSwgYXNzdW1lIGl0IGlzIHN5bmNcbiAgICAgIGlmIChudW1QYXJhbWV0ZXJzIDwgYXJnc1dpdGhvdXRDYi5sZW5ndGggKyAxKSB7XG4gICAgICAgIHJldHVybiBfY2IobnVsbCwgcmV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2IoKSB7XG4gICAgICBjb25zdCBhcmdzV2l0aG91dEVycm9yID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgYXJnc1dpdGhvdXRFcnJvci5zaGlmdCgpO1xuICAgICAgaWYgKG9wdGlvbnMubnVsbFJlc3VsdEJ5RGVmYXVsdCAmJiBhcmdzV2l0aG91dEVycm9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhcmdzV2l0aG91dEVycm9yLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlcnJvclxuICAgICAgICByZXR1cm4gX2hhbmRsZVdyYXBFcnJvcihfdGhpcywgYXJndW1lbnRzWzBdLCBuYW1lLCBjb250ZXh0LFxuICAgICAgICAgIGFyZ3NXaXRob3V0RXJyb3IsIG9wdGlvbnMsIGxhc3RBcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuZXhlY1Bvc3QobmFtZSwgY29udGV4dCwgYXJnc1dpdGhvdXRFcnJvciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGxhc3RBcmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJndW1lbnRzWzBdXG4gICAgICAgICAgICA/IGxhc3RBcmcoYXJndW1lbnRzWzBdKVxuICAgICAgICAgICAgOiBsYXN0QXJnLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEZpbHRlciBjdXJyZW50IGluc3RhbmNlIGZvciBzb21ldGhpbmcgc3BlY2lmaWMgYW5kIHJldHVybiB0aGUgZmlsdGVyZWQgY2xvbmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtLYXJlZW19IFRoZSBjbG9uZWQgYW5kIGZpbHRlcmVkIGluc3RhbmNlXG4gKi9cbkthcmVlbS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc3QgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG5cbiAgY29uc3QgcHJlcyA9IEFycmF5LmZyb20oY2xvbmUuX3ByZXMua2V5cygpKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIHByZXMpIHtcbiAgICBjb25zdCBob29rcyA9IHRoaXMuX3ByZXMuZ2V0KG5hbWUpLlxuICAgICAgbWFwKGggPT4gT2JqZWN0LmFzc2lnbih7fSwgaCwgeyBuYW1lOiBuYW1lIH0pKS5cbiAgICAgIGZpbHRlcihmbik7XG5cbiAgICBpZiAoaG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBjbG9uZS5fcHJlcy5kZWxldGUobmFtZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBob29rcy5udW1Bc3luYyA9IGhvb2tzLmZpbHRlcihoID0+IGguaXNBc3luYykubGVuZ3RoO1xuXG4gICAgY2xvbmUuX3ByZXMuc2V0KG5hbWUsIGhvb2tzKTtcbiAgfVxuXG4gIGNvbnN0IHBvc3RzID0gQXJyYXkuZnJvbShjbG9uZS5fcG9zdHMua2V5cygpKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIHBvc3RzKSB7XG4gICAgY29uc3QgaG9va3MgPSB0aGlzLl9wb3N0cy5nZXQobmFtZSkuXG4gICAgICBtYXAoaCA9PiBPYmplY3QuYXNzaWduKHt9LCBoLCB7IG5hbWU6IG5hbWUgfSkpLlxuICAgICAgZmlsdGVyKGZuKTtcblxuICAgIGlmIChob29rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNsb25lLl9wb3N0cy5kZWxldGUobmFtZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjbG9uZS5fcG9zdHMuc2V0KG5hbWUsIGhvb2tzKTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgZm9yIGEgXCJuYW1lXCIgdG8gZXhpc3QgZWl0aGVyIGluIHByZSBvciBwb3N0IGhvb2tzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHJldHVybnMge0Jvb2xlYW59IFwidHJ1ZVwiIGlmIGZvdW5kLCBcImZhbHNlXCIgb3RoZXJ3aXNlXG4gKi9cbkthcmVlbS5wcm90b3R5cGUuaGFzSG9va3MgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9wcmVzLmhhcyhuYW1lKSB8fCB0aGlzLl9wb3N0cy5oYXMobmFtZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIFdyYXBwZXIgZm9yIFwiZm5cIiBvbiBcIm5hbWVcIiBhbmQgcmV0dXJuIHRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXBcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPdmVyd3JpdGUgdGhlIFwidGhpc1wiIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvblxuICovXG5LYXJlZW0ucHJvdG90eXBlLmNyZWF0ZVdyYXBwZXIgPSBmdW5jdGlvbihuYW1lLCBmbiwgY29udGV4dCwgb3B0aW9ucykge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICghdGhpcy5oYXNIb29rcyhuYW1lKSkge1xuICAgIC8vIEZhc3QgcGF0aDogaWYgdGhlcmUncyBubyBob29rcyBmb3IgdGhpcyBmdW5jdGlvbiwganVzdCByZXR1cm4gdGhlXG4gICAgLy8gZnVuY3Rpb24gd3JhcHBlZCBpbiBhIG5leHRUaWNrKClcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0VGljaygoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBfY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICBfdGhpcy53cmFwKG5hbWUsIGZuLCBfY29udGV4dCwgQXJyYXkuZnJvbShhcmd1bWVudHMpLCBvcHRpb25zKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgaG9vayBmb3IgXCJwcmVcIlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQXN5bmNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgZm9yIFwibmFtZVwiXG4gKiBAcGFyYW0ge25ldmVyfSBlcnJvciBVbnVzZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Vuc2hpZnRdIFdoZXRlciB0byBcInB1c2hcIiBvciB0byBcInVuc2hpZnRcIiB0aGUgbmV3IGhvb2tcbiAqIEByZXR1cm5zIHtLYXJlZW19XG4gKi9cbkthcmVlbS5wcm90b3R5cGUucHJlID0gZnVuY3Rpb24obmFtZSwgaXNBc3luYywgZm4sIGVycm9yLCB1bnNoaWZ0KSB7XG4gIGxldCBvcHRpb25zID0ge307XG4gIGlmICh0eXBlb2YgaXNBc3luYyA9PT0gJ29iamVjdCcgJiYgaXNBc3luYyAhPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBpc0FzeW5jO1xuICAgIGlzQXN5bmMgPSBvcHRpb25zLmlzQXN5bmM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZm4gPSBpc0FzeW5jO1xuICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByZXMgPSB0aGlzLl9wcmVzLmdldChuYW1lKSB8fCBbXTtcbiAgdGhpcy5fcHJlcy5zZXQobmFtZSwgcHJlcyk7XG5cbiAgaWYgKGlzQXN5bmMpIHtcbiAgICBwcmVzLm51bUFzeW5jID0gcHJlcy5udW1Bc3luYyB8fCAwO1xuICAgICsrcHJlcy5udW1Bc3luYztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZSgpIHJlcXVpcmVzIGEgZnVuY3Rpb24sIGdvdCBcIicgKyB0eXBlb2YgZm4gKyAnXCInKTtcbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSB7XG4gICAgcHJlcy51bnNoaWZ0KE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgZm46IGZuLCBpc0FzeW5jOiBpc0FzeW5jIH0pKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBmbjogZm4sIGlzQXN5bmM6IGlzQXN5bmMgfSkpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbmV3IGhvb2sgZm9yIFwicG9zdFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIGZvciBcIm5hbWVcIlxuICogQHBhcmFtIHtCb29sZWFufSBbdW5zaGlmdF0gV2hldGVyIHRvIFwicHVzaFwiIG9yIHRvIFwidW5zaGlmdFwiIHRoZSBuZXcgaG9va1xuICogQHJldHVybnMge0thcmVlbX1cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucywgZm4sIHVuc2hpZnQpIHtcbiAgY29uc3QgcG9zdHMgPSB0aGlzLl9wb3N0cy5nZXQobmFtZSkgfHwgW107XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdW5zaGlmdCA9ICEhZm47XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc3QoKSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBnb3QgXCInICsgdHlwZW9mIGZuICsgJ1wiJyk7XG4gIH1cblxuICBpZiAodW5zaGlmdCkge1xuICAgIHBvc3RzLnVuc2hpZnQoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBmbjogZm4gfSkpO1xuICB9IGVsc2Uge1xuICAgIHBvc3RzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBmbjogZm4gfSkpO1xuICB9XG4gIHRoaXMuX3Bvc3RzLnNldChuYW1lLCBwb3N0cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgY3VycmVudCBpbnN0YW5jZVxuICogQHJldHVybnMge0thcmVlbX0gVGhlIGNsb25lZCBpbnN0YW5jZVxuICovXG5LYXJlZW0ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG4gPSBuZXcgS2FyZWVtKCk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5fcHJlcy5rZXlzKCkpIHtcbiAgICBjb25zdCBjbG9uZSA9IHRoaXMuX3ByZXMuZ2V0KGtleSkuc2xpY2UoKTtcbiAgICBjbG9uZS5udW1Bc3luYyA9IHRoaXMuX3ByZXMuZ2V0KGtleSkubnVtQXN5bmM7XG4gICAgbi5fcHJlcy5zZXQoa2V5LCBjbG9uZSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5fcG9zdHMua2V5cygpKSB7XG4gICAgbi5fcG9zdHMuc2V0KGtleSwgdGhpcy5fcG9zdHMuZ2V0KGtleSkuc2xpY2UoKSk7XG4gIH1cblxuICByZXR1cm4gbjtcbn07XG5cbi8qKlxuICogTWVyZ2UgXCJvdGhlclwiIGludG8gc2VsZiBvciBcImNsb25lXCJcbiAqIEBwYXJhbSB7S2FyZWVtfSBvdGhlciBUaGUgaW5zdGFuY2UgdG8gbWVyZ2Ugd2l0aFxuICogQHBhcmFtIHtLYXJlZW19IFtjbG9uZV0gVGhlIGluc3RhbmNlIHRvIG1lcmdlIG9udG8gKGlmIG5vdCBkZWZpbmVkLCB1c2luZyBcInRoaXNcIilcbiAqIEByZXR1cm5zIHtLYXJlZW19IFRoZSBtZXJnZWQgaW5zdGFuY2VcbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyLCBjbG9uZSkge1xuICBjbG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0cnVlIDogY2xvbmU7XG4gIGNvbnN0IHJldCA9IGNsb25lID8gdGhpcy5jbG9uZSgpIDogdGhpcztcblxuICBmb3IgKGNvbnN0IGtleSBvZiBvdGhlci5fcHJlcy5rZXlzKCkpIHtcbiAgICBjb25zdCBzb3VyY2VQcmVzID0gcmV0Ll9wcmVzLmdldChrZXkpIHx8IFtdO1xuICAgIGNvbnN0IGRlZHVwbGljYXRlZCA9IG90aGVyLl9wcmVzLmdldChrZXkpLlxuICAgICAgLy8gRGVkdXBsaWNhdGUgYmFzZWQgb24gYGZuYFxuICAgICAgZmlsdGVyKHAgPT4gc291cmNlUHJlcy5tYXAoX3AgPT4gX3AuZm4pLmluZGV4T2YocC5mbikgPT09IC0xKTtcbiAgICBjb25zdCBjb21iaW5lZCA9IHNvdXJjZVByZXMuY29uY2F0KGRlZHVwbGljYXRlZCk7XG4gICAgY29tYmluZWQubnVtQXN5bmMgPSBzb3VyY2VQcmVzLm51bUFzeW5jIHx8IDA7XG4gICAgY29tYmluZWQubnVtQXN5bmMgKz0gZGVkdXBsaWNhdGVkLmZpbHRlcihwID0+IHAuaXNBc3luYykubGVuZ3RoO1xuICAgIHJldC5fcHJlcy5zZXQoa2V5LCBjb21iaW5lZCk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2Ygb3RoZXIuX3Bvc3RzLmtleXMoKSkge1xuICAgIGNvbnN0IHNvdXJjZVBvc3RzID0gcmV0Ll9wb3N0cy5nZXQoa2V5KSB8fCBbXTtcbiAgICBjb25zdCBkZWR1cGxpY2F0ZWQgPSBvdGhlci5fcG9zdHMuZ2V0KGtleSkuXG4gICAgICBmaWx0ZXIocCA9PiBzb3VyY2VQb3N0cy5pbmRleE9mKHApID09PSAtMSk7XG4gICAgcmV0Ll9wb3N0cy5zZXQoa2V5LCBzb3VyY2VQb3N0cy5jb25jYXQoZGVkdXBsaWNhdGVkKSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2FsbE1pZGRsZXdhcmVGdW5jdGlvbihmbiwgY29udGV4dCwgYXJncywgbmV4dCkge1xuICBsZXQgbWF5YmVQcm9taXNlTGlrZTtcbiAgdHJ5IHtcbiAgICBtYXliZVByb21pc2VMaWtlID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG5leHQoZXJyb3IpO1xuICB9XG5cbiAgaWYgKGlzUHJvbWlzZUxpa2UobWF5YmVQcm9taXNlTGlrZSkpIHtcbiAgICBtYXliZVByb21pc2VMaWtlLnRoZW4oKCkgPT4gbmV4dCgpLCBlcnIgPT4gbmV4dChlcnIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKHYpIHtcbiAgcmV0dXJuICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiB0eXBlb2Ygdi50aGVuID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVOZXh0Rm4oZm4pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBFbnN1cmUgdGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgb25jZVxuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAvLyBNYWtlIHN1cmUgdG8gY2xlYXIgdGhlIHN0YWNrIHNvIHRyeS9jYXRjaCBkb2Vzbid0IGNhdGNoIGVycm9yc1xuICAgIC8vIGluIHN1YnNlcXVlbnQgbWlkZGxld2FyZVxuICAgIHJldHVybiBuZXh0VGljaygoKSA9PiBmbi5hcHBseShfdGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmNvbnN0IG5leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MgIT09IG51bGwgJiYgcHJvY2Vzcy5uZXh0VGljayB8fCBmdW5jdGlvbiBuZXh0VGljayhjYikge1xuICBzZXRUaW1lb3V0KGNiLCAwKTtcbn07XG5cbmZ1bmN0aW9uIGlzRXJyb3JIYW5kbGluZ01pZGRsZXdhcmUocG9zdCwgbnVtQXJncykge1xuICBpZiAocG9zdC5lcnJvckhhbmRsZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcG9zdC5mbi5sZW5ndGggPT09IG51bUFyZ3MgKyAyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEthcmVlbTtcbiJdLCJuYW1lcyI6WyJLYXJlZW0iLCJfcHJlcyIsIk1hcCIsIl9wb3N0cyIsInNraXBXcmFwcGVkRnVuY3Rpb24iLCJhcmd1bWVudHMiLCJhcmdzIiwib3ZlcndyaXRlUmVzdWx0IiwicHJvdG90eXBlIiwiZXhlY1ByZSIsIm5hbWUiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJsZW5ndGgiLCJwcmVzIiwiZ2V0IiwibnVtUHJlcyIsIm51bUFzeW5jUHJlcyIsIm51bUFzeW5jIiwiY3VycmVudFByZSIsImFzeW5jUHJlc0xlZnQiLCJkb25lIiwiJGFyZ3MiLCJzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uIiwibmV4dFRpY2siLCJuZXh0IiwicHJlIiwiaXNBc3luYyIsImRlY29yYXRlTmV4dEZuIiwiX25leHQiLCJlcnJvciIsImNhbGxNaWRkbGV3YXJlRnVuY3Rpb24iLCJmbiIsIl9hcmdzIiwiY29uY2F0IiwiaSIsInB1c2giLCJtYXliZVByb21pc2VMaWtlIiwiY2FsbCIsImVyciIsImlzUHJvbWlzZUxpa2UiLCJ0aGVuIiwiYXBwbHkiLCJleGVjUHJlU3luYyIsImV4ZWNQb3N0Iiwib3B0aW9ucyIsInBvc3RzIiwibnVtUG9zdHMiLCJjdXJyZW50UG9zdCIsImZpcnN0RXJyb3IiLCJwb3N0IiwibnVtQXJncyIsImFyZ0xlbmd0aCIsIm5ld0FyZ3MiLCJfa2FyZWVtSWdub3JlIiwiaXNFcnJvckhhbmRsaW5nTWlkZGxld2FyZSIsIl9jYiIsInJlcyIsImV4ZWNQb3N0U3luYyIsImNyZWF0ZVdyYXBwZXJTeW5jIiwiX3RoaXMiLCJzeW5jV3JhcHBlciIsInRvUmV0dXJuIiwicmVzdWx0IiwiX2hhbmRsZVdyYXBFcnJvciIsImluc3RhbmNlIiwidXNlRXJyb3JIYW5kbGVycyIsIndyYXAiLCJsYXN0QXJnIiwiYXJnc1dpdGhvdXRDYiIsIkFycmF5IiwiZnJvbSIsInBvcCIsImNoZWNrRm9yUHJvbWlzZSIsIm51bUNhbGxiYWNrUGFyYW1zIiwiZXJyb3JBcmdzIiwiY29udGV4dFBhcmFtZXRlciIsIm51bVBhcmFtZXRlcnMiLCJyZXQiLCJhcmdzV2l0aG91dEVycm9yIiwic2hpZnQiLCJudWxsUmVzdWx0QnlEZWZhdWx0IiwiZmlsdGVyIiwiY2xvbmUiLCJrZXlzIiwiaG9va3MiLCJtYXAiLCJoIiwiT2JqZWN0IiwiYXNzaWduIiwiZGVsZXRlIiwic2V0IiwiaGFzSG9va3MiLCJoYXMiLCJjcmVhdGVXcmFwcGVyIiwiX2NvbnRleHQiLCJ1bnNoaWZ0IiwiRXJyb3IiLCJuIiwia2V5Iiwic2xpY2UiLCJtZXJnZSIsIm90aGVyIiwic291cmNlUHJlcyIsImRlZHVwbGljYXRlZCIsInAiLCJfcCIsImluZGV4T2YiLCJjb21iaW5lZCIsInNvdXJjZVBvc3RzIiwidiIsImNhbGxlZCIsInByb2Nlc3MiLCJjYiIsInNldFRpbWVvdXQiLCJlcnJvckhhbmRsZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/kareem/index.js\n");

/***/ })

};
;